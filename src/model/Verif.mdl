########################################################
#########     VERIFICATION  #####################
########################################################
### This file provides the equations defining check variables
### Check variables begins with verif. They should always be equal to zero in the calibration and in the simulation.

verif_phi_F[s] = 1 - (sum(phi[ff, s] on ff))

verif_phi_MGPD[c] = 1 - (sum(phi_MGPD[cc, c] on cc)) if MGPD[c] <> 0
verif_phi_MGPM[c] = 1 - (sum(phi_MGPM[cc, c] on cc)) if MGPM[c] <> 0

verif_phi[E, s] = 1 - (sum(phi[E, ce, s] on ce)) if F[E, s] <> 0

verif_phi_TRSP[s] = 1 - (sum(phi_TRSP[ct, s] on ct)) if TRSP[s] <> 0


verif_Mbis[c] = Mbis[c] - M[c] if M[c] <> 0

verif_MGRbis[c] = MGRbis[c] - MGR[c] if MGR[c] <> 0
verif_PMGRbis[c] = PMGRbis[c] - PMGR[c] if MGR[c] <> 0

verif_YQbis[c] = YQbis[c] - YQ[c]

Verif_PCH_CES = PCH - PCH_CES  if ES_LESCES <> 1

Verif_phi_MCH = sum(phi_MCH[c] on c) - 1

Verif_phi_CH = sum(phi_CH[c] on c) - 1

Verif_GDPbis = GDPbis - GDP
Verif_PGDPbis = PGDPbis - PGDP

Verif_GDPter = GDPter - GDP
Verif_PGDPter = PGDPter - PGDP

Verif_GDP4 = GDP4 - GDP
Verif_PGDP4 = PGDP4 - PGDP

Verif_CIbis = CIbis - CI
Verif_PCIbis = PCIbis - PCI


Verif_Ibis = Ibis - I
Verif_PIbis = PIbis - PI


Verif_ALL = ( sum(verif_phi_F[s]^2 on s) + sum(verif_phi_MGPD[c]^2 on c) + sum(verif_phi_MGPM[c]^2 on c) + sum(verif_phi[E, s]^2 on s) + sum(verif_phi_TRSP[s]^2 on s) + sum(verif_Mbis[c]^2 on c) + sum(verif_MGRbis[c]^2 on c) + sum(verif_PMGRbis[c]^2 on c) + sum(verif_YQbis[c]^2 on c) + Verif_PCH_CES^2 +Verif_phi_MCH^2 + Verif_phi_CH^2 + Verif_GDPbis^2 + Verif_PGDPbis^2 + Verif_GDPter^2 + Verif_PGDPter^2 + Verif_GDP4^2 + Verif_PGDP4^2 + Verif_CIbis^2 + Verif_PCIbis^2 + Verif_Ibis^2 + Verif_PIbis^2 )^(1/2)


# Verif Compta nat.

#VERIF_PY_PYQ  = PY/PYQ-1
#VERIF_Y_YQ  = PY/PYQ-1

#
# verifYQbis, margins.  


### Verification for the actual elasticities
## The series should converge asymptotically to the inputed elasticities.
## Eviews does not manage optimaly certain conditionalities:
## - it calculate a division by 0 even if the conditionality exclude this case: for the reason we multiply *1.0000000001 to avoid the case 1/log(1) 
## - the condition <> 1 may not be read because of rounding error: for the reason we use < 0.99999 and > 1.00001
## Moreover the compiler does not recognise the operator "OR" in the condition. Therefore, we have to write it twice.
     
ES_act_|V|M[c] = ES_|V|M[c] _ 
					- (P|V|D[c]/P|V|M[c] < 0.99999) * (log(|V|D[c]/|V|M[c]/@elem(|V|D[c]/|V|M[c], %baseyear)) / log(P|V|D[c]/P|V|M[c]*1.0000000001) + ES_|V|M[c]) _
					- (P|V|D[c]/P|V|M[c] > 1.00001) * (log(|V|D[c]/|V|M[c]/@elem(|V|D[c]/|V|M[c], %baseyear)) / log(P|V|D[c]/P|V|M[c]*1.0000000001) + ES_|V|M[c]) if |V|M[c] <> 0 where V in MGR CH G X

Verif_ES_|V|M[c] = ES_act_|V|M[c] - ES_|V|M[c] where V in MGR CH G X

ES_act[f, ff, s] = ES[f, ff, s] - (C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s])/ @elem(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s]), %baseyear) < 0.99999) * (log(F[f, s]*PROG[f, s]/(F[ff, s]*PROG[ff, s])/@elem(F[f, s]*PROG[f, s]/(F[ff, s]*PROG[ff, s]), %baseyear))/ log(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s])/@elem(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s]), %baseyear)*1.0000000001) + ES[f, ff, s]	) - (C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s])/ @elem(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s]), %baseyear) > 1.00001) * (log(F[f, s]*PROG[f, s]/(F[ff, s]*PROG[ff, s])/@elem(F[f, s]*PROG[f, s]/(F[ff, s]*PROG[ff, s]), %baseyear))/ log(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s])/@elem(C[f, s]/PROG[f, s]/(C[ff, s]/PROG[ff, s]), %baseyear)*1.0000000001) + ES[f, ff, s]	)




Verif_ALL_ES = ( sum(Verif_ES_MGRM[c]^2 on c) + sum(Verif_ES_CHM[c]^2 on c) + sum(Verif_ES_GM[c]^2 on c) + sum(Verif_ES_XM[c]^2 on c))^(1/2) where V in MGR CH G X


