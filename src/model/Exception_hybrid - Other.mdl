include ..\model\lists

  
  
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
#*********************************************************************************************************************************
#*****************************************************TRANSPORTS******************************************************************

#-----------------------------------------------------AUTOMOBILE-----------------------------------------------------------------


# Equation H.4.81

EXP_MOBAUTO_Val[ecl] = ( @year > %baseyear ) * (DEBT_AUTO_Val[ecl]{-1} * ( R_I_AUTO[ecl]{-1} + R_RMBS_AUTO[ecl]{-1} ) +   _
                                R_CASH_AUTO[ecl] * PNewAUTO[ecl] * NewAUTO[ecl] * ( 1 - R_SUB_AUTO[ecl] ) +       _
                                PEXP_AUTO[ecl] * EXP_AUTO[ecl] ) +                                                    _
                         ( @year <= %baseyear ) * (EXP_MOBAUTO_Val[ecl]{-1} * ( 1 + GR_NOMI ) )

R_LOAN_AUTO[ecl] = 1 - R_CASH_AUTO[ecl]

GR_PENER_auto_e[ecl] = 0.8*GR_PENER_auto_e[ecl]{-1} + (1 - 0.8) * @pchy(PENER_auto[ecl])


PENER_AUTO[ecl] * km_AUTO[ecl] = PEXP_AUTO[ecl] * EXP_AUTO[ecl] if AUTO[ecl] <> 0
  
# Equation H.4.83

DEBT_auto_Val[ecl] = (@year > %baseyear)*( DEBT_auto_Val[ecl]{-1}*(1 - R_RMBS_AUTO[ecl]) _
                                             + R_LOAN_AUTO[ecl]*PNewAuto[ecl]*NewAuto[ecl]*(1 - R_SUB_AUTO[ecl]) ) _
                       + (@year <= %baseyear)*(DEBT_auto_Val[ecl]{-1}*(1 + GR_NOMI))

# Equation H.4.84

EXP_NEWAUTO_VAL[ecl] = PNewAuto[ecl] * NewAUTO[ecl]



# Equation H.4.89 and H.4.90

km_AUTO[ecl] = sum(km_AUTO[ ecl, ce] on ce)    #modifié

dlog(EXP_AUTO[ecl,ce2]) = d(log(AUTO_th[ecl,ce2])) -dlog(PROG_AUTO)  if AUTO_th[ecl,ce2] <> 0   #modifié

EXP_AUTO[CA,23] = sum(EXP_AUTO_elec[pcl] on pcl)                                             #modifié

EXP_AUTO[c,23] = 0   where c in %list_ener_class \CA                                           #modifié


# -------------------------------------------Aggregation of automobile expenditure--------------------------------------------
# Equation H.4.91

EXP_AUTO[ecl] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ce )

PEXP_AUTO[ecl]*EXP_AUTO[ecl] = sum( PEXP[ce]*EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ce )      # corrigé

# Equation H.4.92

@pv EXP_AUTO = sum( EXP_AUTO[ecl] if EXP_AUTO[ecl] <> 0 on ecl )

EXP_AUTO[ce] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ecl )

# Equation H.4.93

EXP_AUTO[ce] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ecl )


# -----------------------------------------------------------AGGREGATION AUTOMOBILE---------------------------------------------------




 # Equation H.4.99
 PnewAUTO*NewAUTO = PAUTO_elec*NewAUTO_elec + PNewAUTO_th*NewAUTO_th  if NewAUTO <> 0         #modifié
 
# Equation H.4.100
EXP_NEWAUTO_VAL = sum(EXP_NewAUTO_VAL[ ecl] on ecl)


# Equation H.4.103

EXP_MOBAUTO_Val = sum(EXP_MOBAUTO_Val[ ecl] if EXP_MOBAUTO_Val[ ecl] <> 0 on ecl)



# ------------------------------------------------------TRANSPORT COLLECTIF--------------------------------------------------------------
# Equation H.4.113

EXP_MOB_OTH_Val = sum(PEXP[trsp] * EXP[trsp] on trsp in %list_trsp_travel)

# ---------------------------------------------------------Total mobility---------------------------------------------------
# Equation H.4.117

EXP_MOB_Val = EXP_MOBAuto_Val + EXP_MOB_OTH_Val + EXP_03_OTH_VAL



# Subventions automobile ( Bonus-malus auto + bonus elec)

SUB_AUTO_VAL[ ecl] = R_SUB_AUTO[ ecl]*PNewAUTO[ ecl] * NewAUTO[ ecl]

SUB_AUTO_VAL = sum(SUB_AUTO_VAL[ecl] on ecl)



################ Coût du transport au km VP nouvelle version :   modifié

p_mobauto_val*km_AUTO = exp_mobauto_val*1000

d(log(PC_trav_auto_LD)) = d(log(p_mobauto_val))-d(log(travperauto_LD))

d(log(PC_trav_auto_CD)) = d(log(p_mobauto_val))-d(log(travperauto_CD))

################Coût du transport au km en transports en commun     modifié

PC_trav_14*km_traveler_14 = pch_14*ch_14

PC_trav_15*km_traveler_15 = pch_15*ch_15



## prix d'achat du véhicule

PAUTO_elec[pcl] = PNewAUTO_th[pcl]+(Pbattery + overcost_elec)/1000

PAUTO_elec*NewAUTO_elec = sum(PAUTO_elec[pcl]*NewAUTO_elec[pcl] on pcl)

PNewAUTO[CA]*NewAUTO[CA] = PAUTO_elec*NewAUTO_elec + PNewAUTO_th[CA]*NewAUTO_th[CA] if  NewAUTO[CA]>0

dlog(PNewAUTO[ecl,th]) =dlog(PCH_03)

PNewAUTO[c] = PNewAUTO_th[c]  where c in %list_ener_class \ CA

PNewAUTO_th*NewAUTO_th = sum(PNewAUTO_th[ ecl] * NewAUTO_th[ ecl] on ecl)  if NewAUTO_th>0

##Coût d'usage énergétique du véhicule

dlog(PENER_AUTOelec[pcl]) = dlog(pch[23]) + dlog(EXP_AUTO_elec[pcl]) - dlog(AUTO_elec[pcl])

dlog(EXP_AUTO_elec[pcl]) = dlog(km_AUTO_elec[pcl]) - dlog(prog_auto_elec) 

###coût d'usage annualisé de l'énergie

UC_E_auto_elec[pcl]=PENER_autoelec[pcl] #*((1+dlog(PCH))^(AUTO_elec_D[pcl])-1)/(dlog(PCH)*AUTO_elec_D[pcl])
		
R_SUB_AUTO_elec[pcl]= bonus_elec/PAUTO_elec[pcl]

R_SUB_AUTO_elec = sum(R_SUB_AUTO_elec[pcl]*phi_elec[pcl] on pcl )
 		
R_SUB_AUTO[ecl,th]= bonus_th[ecl]/PNewAUTO[ecl,th]
 
R_SUB_AUTO[CA]*NewAUTO[CA] = (R_SUB_AUTO_elec*NewAUTO_elec + R_SUB_AUTO_th[CA]* NewAUTO_th[CA]) if NewAUTO[CA]>0

#R_SUB_AUTO[c]*NewAUTO[c] = R_SUB_AUTO_th[c]* NewAUTO_th[c]  where c in %list_ener_class \ CA  if NewAUTO[c]>0

R_SUB_AUTO[c] = R_SUB_AUTO_th[c]  where c in %list_ener_class \ CA  if NewAUTO[c]>0

R_SUB_AUTO_th*NewAUTO_th = sum(R_SUB_AUTO[ecl,th]*NewAUTO[ecl,th] on ecl )  if NewAUTO_th>0

R_SUB_AUTO = R_SUB_AUTO_th*(1-share_elec) + R_SUB_AUTO_elec*share_elec

###coût d'achat annualisé du véhicule électrique (payé en partie grâce à l'emprunt)

UC_K_auto_elec[pcl] = ((PAUTO_elec[pcl]) / AUTO_elec_D[pcl] ) * ( 1 - R_SUB_AUTO_elec[pcl] ) * (  R_CASH_AUTO_elec[pcl] + _
    R_LOAN_AUTO_elec[pcl] * R_I_AUTO_elec[pcl]{-1} * LD_AUTO_elec[pcl] / ( 1 - ( 1 + R_I_AUTO_elec[pcl]{-1} )^( - LD_AUTO_elec[pcl] ) ) )

##### FOnction d'utilité, Les coefficients proviennent de l'étude de Isis Durrmeyer "To Rebate or not To Rebate"

U_auto_elec[pcl]=-0.76*UC_K_auto_elec[pcl]-0.2*UC_E_auto_elec[pcl]    

d(phi_elec_n[pcl])= (@year>%baseyear)*d(exp(U_auto_elec[pcl])/(sum(exp(U_auto_elec[c]) where c in %list_price_class)))      

phi_elec_n_tot= sum(phi_elec_n[pcl] if  phi_elec_n[pcl]>0 on pcl)   

phi_elec[pcl] = (phi_elec_n[pcl]>0)*phi_elec_n[pcl]/phi_elec_n_tot + (phi_elec_n[pcl]<=0)*0

#####Définition du coût de maintenance (hors batterie) du véhicule électrique:

UC_M_auto_elec=(HOUSEHOLD_HYBRID_AUTO(218,1)*PCH_03/100*km_AUTO/auto)/1000 

UC_auto_elec = sum(@elem(phi_elec[pcl],%baseyear)* (UC_K_auto_elec[pcl] + UC_E_auto_elec[pcl]) on pcl) + UC_M_auto_elec 



PENER_AUTO[ecl,th] *AUTO[ecl,th]= pch[22] * EXP_AUTO[ecl,22] + pch[24] * EXP_AUTO[ecl,24] if AUTO[ecl,th] <> 0

UC_E_AUTO[ecl,th] = PENER_AUTO[ecl,th] #*((1+dlog(PCH))^(AUTO_D[ecl]) - 1 ) / ( dlog(PCH)*AUTO_D[ecl] ) 
      	
UC_K_AUTO[ecl,th] = ((PNewAUTO[ecl,th]) / AUTO_D[ecl] ) * ( 1 - R_SUB_AUTO[ecl,th] ) * (  R_CASH_AUTO[ecl] +      _
      R_LOAN_AUTO[ecl] * R_I_AUTO[ecl]{-1} * LD_AUTO[ecl] / ( 1 - ( 1 + R_I_AUTO[ecl]{-1} )^( - LD_AUTO[ecl] ) ) )

U_AUTO[ecl,th]=-0.76*UC_K_AUTO[ecl,th]-0.2*UC_E_AUTO[ecl,th]                   

d(phi_th_n[ecl]) = (@year>%baseyear)*d(exp(U_AUTO[ecl,th])/(sum(exp(U_auto_th[c]) where c in %list_ener_class))) 

phi_th_n_tot = sum(phi_th_n[ecl]  if  phi_th_n[ecl]>0 on ecl)   

phi_NewAUTO[ecl,th] = (phi_th_n[ecl]>0) * phi_th_n[ecl]/phi_th_n_tot + (phi_th_n[ecl]<=0)*0    

UC_M_auto_th=(HOUSEHOLD_HYBRID_AUTO(219,1)*PCH_03/100*km_AUTO_th/(auto-auto_elec))/1000

UC_auto_th = sum(@elem(phi_NewAUTO[ecl,th],%baseyear)* (UC_K_AUTO[ecl,th] + UC_E_AUTO[ecl,th]) on ecl) + UC_M_auto_th
 
#### cf.hypothèses de l'étude du CGDD #Analyse coûts bénéfices des véhicules électriques" réalisée par Stéphane Taszka et Silvano Domergue. cf; Modèle de Bass (1963)
             
share_th = 1-share_elec

share_elec= phiNVE*(phiNVE<=1) + (phiNVE=1)

share_elec =  share_elec
  
 d(phiNVE)=innovation * (1-phiNVE{-1}) + imitation * (phiNVE{-1}) * (1-phiNVE{-1})
   
 imitation =  coeffBassimit 
   
 innovation = coeffBassinnov 
  
 d(coeffBassinnov) = ES_BASS*d((2*UC_auto_elec)^(-nu_diffusion)/((2*UC_auto_elec)^(-nu_diffusion)+(UC_auto_th)^(-nu_diffusion)))      
  
U_auto_elec * @elem(NewAUTO_elec,%baseyear) = sum(U_auto_elec[pcl] * @elem(NewAUTO_elec[pcl],%baseyear) on pcl)
  
U_auto_th * @elem(NewAUTO_th,%baseyear) = sum(U_AUTO[ecl,th] * @elem(NewAUTO[ecl,th],%baseyear) on ecl)

##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


 # Modal shift in transportation
 ## modal_shift_freight * (1 + 1/4)????
 ### NE PAS INCLURE DANS V3
@over d(log(MAT[16, s])) = d(log(MAT[s])) + d(SUBST_MAT[16, s]) + log(1 -  modal_shift_freight * (1 + 1/4) * MAT[16, s]{-1} / MAT[16, s]{-1}) if MAT[16, s] <> 0

@over d(log(MAT[14, s])) = d(log(MAT[s])) + d(SUBST_MAT[14, s]) + log(1 +  modal_shift_freight             * MAT[16, s]{-1} / MAT[14, s]{-1}) if MAT[14, s] <> 0

@over d(log(MAT[17, s])) = d(log(MAT[s])) + d(SUBST_MAT[17, s]) + log(1 + (modal_shift_freight / 4)        * MAT[16, s]{-1} / MAT[17, s]{-1}) if MAT[17, s] <> 0
 


    
    # Exception for the households block
    
  
  # -----------------------------------------------Households expenditures --------------------------------
  # equation H.4.139
  
  @over d(log(NEXP[co])) = (@year >  %baseyear) * d(log(Pop_TOT)) + (@year <=  %baseyear) * log( 1 + GR_REAL)  where co in 01
  



## ------------------------ implicit price signal insertion  
### Should noe use the new more general specification!!!
## Should PE_Signal[s] really appeat in the denominator of the share
  @over d(SUBST_E_n[s]) = _
     -eta_K_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CK[s]))   * (K[s]{-1}   * CK[s]{-1}                 / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -eta_L_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CL[s]))   * (L[s]{-1}   * PROG_L[s]{-1} * CL[s]{-1} / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 6) * d(log((PE[s] + PE_Signal[s])) - log(PMAT[s])) * (MAT[s]{-1} * PMAT[s]{-1}               / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if E_n[s] <> 0
   
   
   @over d(SUBST_E_n[ce, s]) = sum( -ES_NRJ($s, cols_ce(ce, ce_oth)) * d(log(PE[ce, s] + PE_Signal[ce, s]) - log(PE[ce_oth, s] + PE_Signal[ce_oth, s])) * _
                              (PE[ce_oth, s]{-1} + PE_Signal[ce_oth, s]{-1})*E[ce_oth, s]{-1} / ((PE[s]{-1}+PE_Signal[s]{-1})*E[s]{-1}) if ce_oth <> ce on ce_oth in %list_com_E) _
                         if E[ce, s] <> 0
     
   
  ##-------------------- Endogenous elasticity
   
dlog(PE_a[sne]) =  0.8*dlog(PE_a[sne]{-1}) + (1-0.8)*dlog(PE[sne]) + 0.01*(log(PE[sne]{-1})- log(PE_a[sne]{-1})) 
   
dlog(CK_a[sne]) = 0.8*dlog(CK_a[sne]{-1})+ (1-0.8)*dlog(CK[sne]) + 0.01*(log(CK[sne]{-1})- log(CK_a[sne]{-1})) 
  
 @over d(eta_K_E_des[sne]) = (@year>2006) * (alpha_eta_K_E_PE[sne] * d(dlog(PE_a[sne])-dlog(CK_a[sne])))*(d(dlog(PE_a[sne])-dlog(CK_a[sne]))>0)
   
 @over eta_K_E[sne] = 0.5*eta_K_E[sne]{-1} +(1-0.5)*(eta_K_E_des[sne]) +0.1*(eta_K_E_des[sne]{-1}-eta_K_E[sne]{-1})



# sobriété, reglementation thermique, substitution interénergie dans logement

@over d(log(ENERperM2[ ecl, ce])) = -eta_BUIL* d(log(PEXP[ce])-log(PCH))*(d(log(PEXP[ce])-log(PCH))>0) + d(SUBST_BUIL[ ecl, ce]) if ENER_BUIL[ ecl, ce] <> 0

d(SUBST_BUIL[ ecl, ce]) = (@year>%baseyear)*(sum(-ES_BUILNRJ($ecl, cols_ce(ce, ce_oth)) * d(log(PEXP[ce]) - log(PEXP[ce_oth])) * _
                           (PEXP[ce_oth]{-1}*EXP_BUIL[ ecl, ce_oth]{-1}) /(PEXP_BUIL[ ecl]{-1}*EXP_BUIL[ ecl]{-1}) if ce_oth <> ce on ce_oth in %list_com_E))_
                            if  PEXP[ce]*EXP_BUIL[ ecl, ce] <> 0




   
##################################################################################################################################
############################ EMISSION ############################################################################################
##################################################################################################################################   
   
NE PAS REPRENDRE !!!! RELIER DIRECTEMENT AUX VOLUME COMPTAT NAT / Q_Mtep SONT SEULLEMENT DES SORTIES
POUR MEMOIRE. VOIR COMMMENT SIMPLIFIER 

    # Exception regarding MTEP/CO2EMS
    
    # Carbon intentity endogenous
    
    IC[22,s] = PhiY_ener[22, 2201]    #modifié Gaël
    
    IC[24,s] = PhiY_ener[24, 2401]    #modifié Gaël
    
    IC_HH[22] = PhiY_ener[22, 2201]  #modifié Gaël
                                      
    IC_HH[24] = PhiY_ener[24, 2401]    #modifié Gaël
    
    # Emission linked to internal uses of the branche
    
    @over d(log(EMS_SEC[22,2201])) = (@year>%baseyear)*d(log(Q_Mtep_int[22,2201])) + (@year=<%baseyear)*log(1 + GR_REAL)
    
    # household's emissions per source
    
    @over  d(log(EMS_HH[ce2])) = (@year>%baseyear)*dlog((Q_Mtep_H_Buil[ce2]+Q_Mtep_H_AUTO[ce2])*IC_HH[ce2]) + (@year=<%baseyear)*log(1 + GR_REAL) if EMS_HH[ce2] <> 0     #modifié Gaël
    
    # sector's emissions for energy and non energy uses
    
    dlog(EMS_SEC_indus[ce2,s]) = dlog(Q_Mtep_indus[ce2,s])  if EMS_SEC_indus[ce2,s]<>0   # modifié Gaël
      
    # for energy and non energy uses
    
      EMS_SEC_tot[ce2,s] = EMS_SEC[ce2,s] + EMS_SEC_indus[ce2,s]     # modifié Gaël
        
      EMS_SEC_tot[s] = sum(EMS_sec_tot[ce2,s] on ce2)                   # modifié Gaël
      
      EMS_SEC_tot = sum(EMS_sec_tot[s] on s)                            # modifié Gaël
    
    
    ### We should also include the following equation. But this would require reformulating the calculation of the
    ### different PhiY. We neglet this since EMS_SEC[24,2201] represent only 0.7% of the emission of sector 2201
    ### we therefore keep the orginal formulation: d(log(EMS_SEC[ce2,s])) = d(log(E[ce2,s]*IC[ce2,s]))
    ### @over d(log(EMS_SEC[24,2201])) = d(log(Q_Mtep_int[24,2201]))
    
    @over d(log(EMS_SEC[24,2401])) = (@year>%baseyear)*d(log(Q_Mtep_int[2401])) + (@year=<%baseyear)*log(1 + GR_REAL)
    
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


    # Share of energy commodities produced by energy sectors (national account definition)
    
    PhiY[ce, se] = PhiY_ef_tot[ce, se] * (1 - (sum(PhiY[ce, sne] if PhiY[ce, sne] <> 0 on sne))) if PhiY[ce, se] <> 0
    
    verif_PhiY[ce] = sum(PhiY[ce, s] if PhiY[ce, s] <> 0 on s) - 1
    
    # Share of final energy production (including fuel for industrial use)
    
    PhiY_ef_tot[ce, se] = Q_Mtep_ef_tot[ce,se]/Q_Mtep_ef_tot_SOU[ce] if PhiY_ef_tot[ce, se] <> 0
    
    Q_Mtep_ef_tot_SOU[ce] = sum(Q_Mtep_ef_tot[ce,se] on se)
    
    # Final energy share of energy commodities produced by energy sectors
    
    verif_PhiY_ef_tot[ce] = sum(PhiY_ef_tot[ce, se] if PhiY_ef_tot[ce, se] <> 0 on se) - 1
    
    # ***ENERGY PRODUCTION IN MTEP***
    
    # Final energy demand (excluding fuel for industrial use)
    
    Q_Mtep_ef[ce,se] = Q_Mtep_ef_SOU[ce] * PhiY_ener[ce, se] if PhiY_ener[ce, se] <> 0
    
    #-----------------------------Energy consumption in Mtep by use -----------------------------
    
    # Energy demand of Household by use
    
    d(log(Q_Mtep_H_BUIL[ce])) = (@year>%baseyear)*d(log(EXP_BUIL[ce])) + (@year=<%baseyear)*log(1 + GR_REAL) if EXP_BUIL[ce] <> 0 
    
    d(log(Q_Mtep_H_AUTO[ce])) = (@year>%baseyear)*d(log(EXP_AUTO[ce])) + (@year=<%baseyear)*log(1 + GR_REAL) if EXP_AUTO[ce] <> 0
    
    # Energy demand of sectors    
                                               
    d(log(Q_Mtep_SEC[ce, sne])) = (@year>%baseyear)*d(log(E_oth[ce, sne])) + (@year=<%baseyear)*log(1 + GR_REAL) if Q_Mtep_SEC[ce, sne] <> 0
    
    #---------------------------------------------------------------------------------------------
    
    
    Q_Mtep_X[ce,se]  = Q_Mtep_X_SOU[ce]  * PhiY_ener[ce, se] if Q_Mtep_X[ce,se] <> 0
    
    Q_Mtep_ef_SOU[ce] = Q_Mtep_H_BUIL[ce] + Q_Mtep_H_AUTO[ce] + Q_Mtep_SEC_SOU[ce]
    
    d(log(Q_Mtep_X_SOU[ce])) = d(log(X[ce])) if Q_Mtep_X_SOU[ce] <> 0
    
    # Energy production for non-energy/indus use
    ### For sector 8 (petrochemistry):  plastic made with petrol and fertilizer made with natural  gas;
    ### For sector 10 (steal): coal to make steal
    ### The reason for showing these is that most policy to reduce CO2 emmissions do not target emission from
    ### fuel for on-energy use.
    
    d(log(Q_Mtep_indus[ce,sne])) = d(log(E_indus[ce,sne])) if Q_Mtep_indus[ce,sne] <> 0
    
    # Energy internal uses and losses of the energy producers
    
    Q_Mtep_int[ce,se] = coef_int[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_int[ce,se] <> 0    # modifié
    
    Q_Mtep_Losses[ce,se] = coef_Losses[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_Losses[ce,se] <> 0     # modifié
    
    
    # Energy Production in total final energy (including "energy"/fuel for non-energy/indus use)
    
    Q_Mtep_ef_tot[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_Nener[ce,se] if  Q_Mtep_ef_tot[ce,se] <> 0
    
    Q_Mtep_Nener[ce,se] =  Q_Mtep_indus[ce]*PhiY_indus[ce,se]
    
    Q_Mtep_Nener[ce] =  Q_Mtep_indus[ce]
    
    # Energy Production in primary energy (for energy use)
    
    Q_Mtep_ep[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_int[ce,se] + Q_Mtep_Losses[ce,se] if Q_Mtep_ep[ce,se] <> 0
    
    # Agregations of Q_Mtep
    
    Q_Mtep_|V|[se] = sum(Q_Mtep_|V|[ce,se] if Q_Mtep_|V|[ce,se] <> 0 on ce) if Q_Mtep_|V|[se] <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_|V| = sum(Q_Mtep_|V|[se] if Q_Mtep_|V|[se] <> 0 on se) if Q_Mtep_|V| <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_indus[ce] = sum(Q_Mtep_indus[ce,sne] on sne)   
    
    Q_Mtep_H_BUIL = sum(Q_Mtep_H_BUIL[ce] on ce)
    
    Q_Mtep_H_AUTO = sum(Q_Mtep_H_AUTO[ce] on ce)
    
    Q_Mtep_SEC_SOU[ce] = sum(Q_Mtep_SEC[ce, sne] on sne)
    
    Q_Mtep_SEC[sne] = sum(Q_Mtep_SEC[ce, sne] on ce)
    
    Q_Mtep_H = Q_mtep_H_BUIL + Q_mtep_H_AUTO
    
    Q_Mtep_SEC = sum(Q_Mtep_SEC_SOU[ce] on ce)
    
    verif_Q_Mtep_ep = Q_Mtep_ef + Q_Mtep_Losses + Q_Mtep_int + Q_Mtep_X - Q_Mtep_ep
    
    verif_Q_Mtep_ef_SOU[ce] = sum(Q_Mtep_ef[ce,se] on se) - Q_Mtep_ef_SOU[ce]
    
    verif_Q_Mtep_X_SOU[ce] = sum(Q_Mtep_X[ce,se] on se) - Q_Mtep_X_SOU[ce]
    
    Verif_Q_Mtep_HSEC = Q_Mtep_H + Q_Mtep_SEC - Q_Mtep_ef
    
    # Exception for energy (Distinction between energy indus / other)
    
    #CU_oth[s]*Y[s] = CK[s]*K[s] + CL[s]*L[s]*PROG_L[s] + PE[s]*E_oth[s] + PMAT[s]*MAT[s] if Y[s] > 0
    
    # E_oth[s]: energy used within sector s for energy purposes (ex: electricity for steel making)
    
    d(log(E_oth_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E[s])) if E_oth_n[s] <> 0
    
    # E_indus[s]: energy carrier used within sector s for non-energy purposes (ex: petrochemical feedstock)
    
    d(log(E_indus_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E_indus[s])) if E_indus_n[s] <> 0     #modifié
    
    # Ajustment of E_oth[s] and E_indus[s]
    
    log(|V|[s]) = ADJUST(2 + $V, 1) * log(|V|_n[s]) + (1 - ADJUST(2 + $V, 1)) * (log(|V|[s]{-1}) + d(log(|V|_e[s]))) if |V|[s] <> 0 where V in E_oth E_indus, s in %list_sec
    
    # E_oth[s] = sum( E_oth[ce, s] on ce )
    
    # E_indus[s] = sum( E_indus[ce, s] on ce )
    
    d(log(|V|_e[s])) = ADJUST(2 + $V, 2) * d(log(|V|_e[s]{-1})) + ADJUST(2 +$V, 3) * d(log(|V|[s]{-1})) + ADJUST(2 + $V, 4) * d(log(|V|_n[s])) if |V|[s] <> 0 where V in E_oth E_indus
    
    # equation 2.20
    
    d(log(E_indus[ce, s])) = d(log(E_indus[s])) + d(SUBST_E[ce, s]) if E_indus[ce, s] <> 0
    
    d(log(E_oth[ce, s])) = d(log(E_oth[s])) + d(SUBST_E[ce, s]) if E_oth[ce, s] <> 0
    
    E_indus_SOU[ce] = sum( E_indus[ce, s] on s )
    
    E_oth_SOU[ce] = sum( E_oth[ce, s] on s)
    
    # Internal energy use in energy producing sectors
    
    E_oth_SOU_ener[ce] = sum(E_oth[ce, se] on se)
    
    # Internal energy use in non-energy producing sectors
    
    E_oth_SOU_non_ener[ce] = sum(E_oth[ce, sne] on sne)
    
    @over E[ce, s] = E_indus[ce, s] + E_oth[ce, s] if E[ce, s] <> 0
    
    @over E[s] = E_indus[s] + E_oth[s]  if E[s] <> 0
    
    verif_E[s] = sum( E[ce, s] on ce ) - E[s] if E[s] <> 0




# Cross-consumption between energy sectors
# Q_Mtep_ener_in[ce, se]: intermediate energy consumed by sector se to produce energy commodity ce
# Q_Mtep_ener_out[ce, se]: intermediate energy ce produced by sector se to be consumed by other energy sectors

@over Q_Mtep_ef_tot[ce, se] = Q_Mtep_ef[ce, se]  + Q_Mtep_X[ce, se] + Q_Mtep_Nener[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ef_tot[ce, se] <> 0

# Take cross-consumptions into account for primary energy consumption

@over Q_Mtep_ep[ce, se] = Q_Mtep_ef[ce, se] + Q_Mtep_X[ce, se] + Q_Mtep_int[ce, se] + Q_Mtep_Losses[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ep[ce,se] <> 0


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
