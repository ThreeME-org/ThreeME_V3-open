include ..\model\lists


 
 
   
  # Equation H.4.39  H.4.40
  
    d(tau_REHAB_N[ecl]) = (@year>%baseyear)*(- nu_REHAB[ecl]*dlog(Payback_REHAB[ecl])) if tau_REHAB[ecl] <> 0      #modifié
  
    tau_REHAB_2[ecl] = ADJUST(74,1)*tau_REHAB_N[ecl] + (1-ADJUST(74,1))*tau_REHAB[ecl]{-1} if tau_REHAB[ecl] <> 0
    
    tau_REHAB[ecl] = 1 * (tau_REHAB_2[ecl] >= 1) + 0.000000001 * (tau_REHAB_2[ecl] =< 0) + _
  		       tau_REHAB_2[ecl] * (tau_REHAB_2[ecl] > 0) * (tau_REHAB_2[ecl] < 1) if tau_REHAB[ecl] <> 0
  
  
    Payback_REHAB_r[ecl] = (UC_K_REHAB[ecl]*BUIL_D[ecl] - UC_K[ecl]*BUIL_D[ecl])/(UC_E[ecl] - UC_E_REHAB[ecl]) - 1 if REHAB[ecl] <> 0
  
    # Reminder: max(a, b) = 1/2 * (a + b + |a - b|)
    # Here, Payback_REHAB[ecl] = max(1, Payback_REHAB_real[ecl]) to exclude negative values and allow log(Payback_REHAB[ecl]) above
    # NB: The function @max(a, b) doesn't exist in eViews...
    
    Payback_REHAB[ecl] = 1/2 * (1 + Payback_REHAB_r[ecl] + @abs(1 - Payback_REHAB_r[ecl])) if REHAB[ecl] <> 0
  
  
  #ajout Gaël
  
  U_REHAB[ecl,ecl2] = (UC_E[ecl]{-1} - UC_E[ecl2]{-1}) - ((1 - R_SUB[ecl,ecl2]{-1}) * PREHAB[ecl,ecl2]{-1})   if REHAB[ecl,ecl2] <> 0
  
  EXP_U_REHAB[ecl,ecl2]= EXP(U_REHAB[ecl,ecl2]*6000)   if REHAB[ecl,ecl2] <> 0
  
  SUM_EXP_U_REHAB[ecl] = sum(EXP_U_REHAB[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2)    if REHAB[ecl] <> 0
  
  d(phi_REHAB_n[ecl,ecl2]) = (@year>2007)*d(EXP_U_REHAB[ecl,ecl2]/SUM_EXP_U_REHAB[ecl])  if REHAB[ecl,ecl2] <> 0  if REHAB[ecl] <> 0
  
  SUM_phi_REHAB_n[ecl] = (sum(phi_REHAB_n[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2))   if REHAB[ecl] <> 0
  
  phi_REHAB[ecl,ecl2] = (phi_REHAB_n[ecl,ecl2]/SUM_phi_REHAB_n[ecl])  if REHAB[ecl,ecl2] <> 0 if REHAB[ecl] <> 0
  
  #U_REHAB[ecl,ecl2] = 1000000*((UC_E[ecl]{-1} - UC_E[ecl2]{-1}) - ((1 - R_SUB[ecl,ecl2]{-1}) * PREHAB[ecl,ecl2]{-1}))   if REHAB[ecl,ecl2] <> 0
  #
  #SUM_U_REHAB[ecl] = sum(U_REHAB[ecl,ecl2]^(-1) if REHAB[ecl,ecl2] <> 0 on ecl2)    if REHAB[ecl] <> 0
  #
  #d(phi_REHAB_n[ecl,ecl2]) = (@year>2007)*d(U_REHAB[ecl,ecl2]^(-1)/SUM_U_REHAB[ecl])  if REHAB[ecl,ecl2] <> 0  if REHAB[ecl] <> 0
  #
  #SUM_phi_REHAB_n[ecl] = (sum(phi_REHAB_n[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2))   if REHAB[ecl] <> 0
  #
  #phi_REHAB[ecl,ecl2] = (phi_REHAB_n[ecl,ecl2]/SUM_phi_REHAB_n[ecl])  if REHAB[ecl,ecl2] <> 0 if REHAB[ecl] <> 0
  
  # Equation H.4.41
  
  REHAB[ecl,ecl2] = (@year>%baseyear)*(phi_REHAB[ecl,ecl2]*tau_REHAB[ecl]*BUIL[ecl]{-1}) + _
                      (@year<=%baseyear)*@elem(REHAB[ecl,ecl2],%baseyear)*(1+STEADYSTATE(2,1))^(@year-%baseyear) if REHAB[ecl,ecl2] <> 0
   
   # Equation H.4.42
   
   sum_phi_REHAB[ecl] = sum(phi_REHAB[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2) if REHAB[ecl] <> 0
       
   # Equation H.4.43
   
   UC_REHAB[ecl] = UC_K_REHAB[ecl] + UC_E_REHAB[ecl] if REHAB[ecl] <> 0
   
   # Equation H.4.44
   
   UC_E_REHAB[ecl] = sum(@elem(phi_REHAB[ecl,ecl2],%baseyear)*UC_E[ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2) if REHAB[ecl] <> 0   #modifié
   
   # Equation H.4.45
   
   UC[ecl] = UC_K[ecl] + UC_E[ecl]
   
   # Equation H.4.46 H.4.47  H.4.48'
   
   UC_K_REHAB[ecl] = PREHAB_delta[ecl] * ( R_CASH_REHAB[ecl] + R_LOAN_REHAB[ecl] * R_I_REHAB[ecl]{-1} * LD_REHAB[ecl] / _
                                               ( 1 - ( 1 + R_I_REHAB[ecl]{-1})^( -LD_REHAB[ecl] ) ) ) if REHAB[ecl] <> 0    
   
   R_LOAN_REHAB[ecl] = 1 - R_CASH_REHAB[ecl] if REHAB[ecl] <> 0
   
   # Equation H.4.49 H.4.50  H.4.51'
   
   UC_K[ecl] = ( PREHAB[ecl,ecl] / BUIL_D[ecl] ) * (R_CASH[ecl] + R_LOAN[ecl] * R_I_BUIL[ecl]{-1} * LD[ecl] / _
                 ( 1 - ( 1 + R_I_BUIL[ecl]{-1}) ^( -LD[ecl] ) ) )
   
   R_LOAN[ecl] = 1 - R_CASH[ecl]
   
   # Equation H.4.52
   
   delta_REHAB[ecl] = sum( @elem(phi_REHAB[ecl,ecl2],%baseyear) * delta_BUIL[ecl2] if phi_REHAB[ecl,ecl2] <> 0 on ecl2 ) if REHAB[ecl] <> 0
   
   # Equation H.4.53
   
   delta_BUIL[ecl] = sum( delta_BUIL[ecl,bcl]                         _
                            if delta_BUIL[ecl,bcl] <> 0                 _
                            on bcl )
   
   
     # Equation H.4.54, H.4.55, and H.4.56
  
UC_E[ ecl] = PENER_m2[ ecl] * ( ((1 + GR_PENER_m2_e[ ecl]) ^ BUIL_D[ ecl] - 1) / (GR_PENER_m2_e[ ecl] * BUIL_D[ ecl]) )    # modifié
    
PENER_m2[ecl]  = PENER_BUIL[ecl] * ENER_BUIL[ecl]/BUIL[ecl] 
     
GR_PENER_m2_e[ecl] = (@year>%baseyear)*(ADJUST(72,2) * GR_PENER_m2_e[ecl]{-1} + ( 1-ADJUST(72,2) ) * @pchy( PENER_m2[ecl]{-1} )) + _
                          (@year<=%baseyear)*(STEADYSTATE(15,1))  if PENER_m2[ecl] <> 0

#GR_PENER_m2_e[ecl] =   PENER_BUIL[ecl]/PENER_BUIL[ecl]{-1}-1 if PENER_m2[ecl] <> 0
       
   # Equation H.4.57
   
   PREHAB_delta[ecl] = sum( (1 - R_SUB[ecl,ecl2]) * PREHAB[ecl,ecl2] * @elem(phi_REHAB[ecl,ecl2],%baseyear) / REHAB_D[ecl2] _
                        if REHAB[ecl,ecl2]  <> 0 on ecl2) if REHAB[ecl]  <> 0               #modifié
   
    # Equation H.4.58
    
   Ver_PREHABdelta[ecl] * REHAB[ecl] =     _
           -PREHAB_delta[ecl] +              _
           sum( (1 - R_SUB[ecl,ecl2]) * PREHAB[ecl,ecl2] * phi_REHAB[ecl,ecl2] * delta_BUIL[ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2 ) if REHAB[ecl] <> 0
   
   # Equation H.4.59 H.4.60  H.4.61  H.4.62 H.4.63  H.4.64
   
   EXP_HOUSING_Val[ecl] = ( @year > %baseyear ) * ( DEBT_REHAB_Val[ecl]{-1} * (R_I_REHAB[ecl]{-1} + R_RMBS_REHAB[ecl]{-1} ) _
                                                      + R_CASH_REHAB[ecl] * PREHAB[ecl] * REHAB[ecl] _
                                                      + DEBT_NewB_Val[ecl]{-1} * ( R_I_NewBUIL[ecl]{-1} + R_RMBS_NewBUIL[ecl]{-1} ) _
                                                      + R_CASH_NewBUIL[ecl] * PNewBUIL[ecl] * NewBUIL[ecl] _
                                                      + PENER_BUIL[ecl] * ENER_BUIL[ecl] ) _
                            + ( @year =< %baseyear ) * EXP_HOUSING_Val[ecl]{-1} * ( 1 + STEADYSTATE(1,1) )
   
   DEBT_REHAB_Val[ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_REHAB[ecl] ) * DEBT_REHAB_Val[ecl]{-1} _
                                                   + R_LOAN_REHAB[ecl] * PREHAB[ecl] * REHAB[ecl] ) _
                           + (@year =< %baseyear) * DEBT_REHAB_Val[ecl]{-1} * ( 1 + STEADYSTATE(1,1) )
   
   DEBT_NewB_Val[ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_NewBUIL[ecl] ) * DEBT_NewB_Val[ecl]{-1} _
                                                  + R_LOAN_NewBUIL[ecl] * PNewBUIL[ecl] * NewBUIL[ecl] ) _
                          + (@year =< %baseyear) * DEBT_NewB_Val[ecl]{-1} * ( 1 + STEADYSTATE(1,1) )
   
   d( log( PNewBUIL[ecl] ) ) = d( log( PCH[13] ) )
   
   d( log( PREHAB[ecl,ecl2] ) ) = d( log( PCH[13] ) ) if REHAB[ecl,ecl2] <> 0
   
   d( log( PREHAB[ecl,ecl] ) ) = d( log( PCH[13] ) )  # Must be added because REHAB[ecl,ecl] = 0  (test if merging the 2 eq. does not change the results)
   
   #------------AGGREGATION IN M2 AND IN MILLION EURO
   
   REHAB[ecl] = sum(REHAB[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2) if REHAB[ecl] <> 0
   
   PREHAB[ecl]*REHAB[ecl] = sum((1 - R_SUB[ecl,ecl2])*PREHAB[ecl,ecl2]*REHAB[ecl,ecl2] if REHAB[ecl,ecl2] <> 0 on ecl2) if REHAB[ecl] <> 0
   
   @pv REHAB = sum( REHAB[ecl] if REHAB[ecl] <> 0 on ecl )
   
 
   EXP_HOUSING_Val = sum(EXP_Housing_Val[ecl] if EXP_Housing_Val[ecl] <> 0 on ecl)
   
   EXP_HOUSING_Val = sum(EXP_HOUSING_Val if EXP_HOUSING_Val <> 0 on h)
   
   EXP_REHAB_VAL = PREHAB * REHAB
   
 
   EXP_NEWBUIL_VAL = ( PNEWBUIL * NEWBUIL )
   
   # Equation H.4.66
   
   
   # Equation H.4.67 and H.4.68
   
   d(log( EXP_13_OTH_VAL ) ) = d( log( DISPINC_VAL ) ) + d( log( 1 - MPS_HH ) )
   
   
   
                       
   #------------------------------------------AGGREGATION NEWBUIL-----------------------------------------------------
   @pv NEWBUIL = sum( NEWBUIL[ecl] if NEWBUIL[ecl] <> 0 on ecl )             
   
   #--------------------------------------------------------- VERIFICATIONS-----------------------------------------
   
   # Equation H.4.71
   
   BUIL_verif = sum( BUIL[ecl] on ecl )
   
   # Equation H.4.72
   
   
   
   
   # Equation H.4.74
   
   verif_phi_REHAB[ecl] = sum_phi_REHAB[ecl] - 1 if REHAB[ecl] <> 0
    
   # ******************************************************************************************************************
   # ---------------------------------------ENERGY CONSUMPTION IN BUILDING---------------------------------------------
   
    # Equation H.4.118, H.4.119, and H.4.120
    
    ENER_BUIL[ ecl, ce] = ENERperM2[ ecl, ce] * BUIL[ ecl] if ENER_BUIL[ ecl, ce] <> 0
    
    # sobriété, reglementation thermique, substitution interénergie  integré dans exceptions_ADEMEhaut
    
    d(log(ENERperM2[ ecl, ce])) = 0 if ENER_BUIL[ ecl, ce] <> 0
    
    d(log(EXP_BUIL[ ecl, ce])) = (@year<=%baseyear)*log(1+STEADYSTATE(2,1)) + _ 
                                  (@year>%baseyear)*d(log(ENER_BUIL[ ecl, ce])) if ENER_BUIL[ ecl, ce] <> 0
    
    PEXP_BUIL[ ecl]*EXP_BUIL[ ecl] = sum(PEXP[ce]*EXP_BUIL[ ecl, ce] if EXP_BUIL[ecl,ce] <> 0 on ce)
    
    EXP_BUIL[ ecl] =  sum(EXP_BUIL[ ecl, ce] if EXP_BUIL[ecl,ce] <> 0 on ce)
    
    EXP_BUIL[ ce] =  sum(EXP_BUIL[ ecl, ce] if EXP_BUIL[ecl,ce] <> 0 on ecl) 
    
    # Equation H.4.121
    # donne le prix en million d'euros du kwH de l'energie concerné
   
   PENER_BUIL[ ecl, ce] * ENER_BUIL[ ecl, ce] = PEXP[ce] * EXP_BUIL[ ecl, ce] if ENER_BUIL[ ecl, ce] <> 0
   
   
   # ------------AGGREGATION CONSOMMATION D'ENERGIE EN KwH ET EN MILLION D'EURO
   
   # Equation H.4.123
   
   @pv ENER_BUIL[ ecl] = sum(ENER_BUIL[ ecl, ce] if ENER_BUIL[ ecl, ce] <> 0 on ce)
   
   # *****************************
   
   # Equation H.4.125
   
   @pv ENER_BUIL = sum(ENER_BUIL[ ecl] if ENER_BUIL[ ecl] <> 0 on ecl)
   
   @pv EXP_BUIL =  sum(EXP_BUIL[ecl] if EXP_BUIL[ecl] <> 0 on ecl)
   
   # *****************************
   
  
   
   # *****************************
   
   # Equation H.4.129
   
   @pv ENER_BUIL[ ce] = sum(ENER_BUIL[ ecl, ce] if ENER_BUIL[ ecl, ce] <> 0 on ecl)
   
   # Equation H.4.131
   
   @pv ENER_BUIL[ce] = sum(ENER_BUIL[ ce] if ENER_BUIL[ ce] <> 0 on h)
   
   # ----AGGREGATION Of total energie expenditure (automobile +building)
   # Equation H.4.132 H.4.133
   # eq en volume
   
   ENER[ ecl] = @elem(PENER_BUIL[ ecl], %baseyear) * ENER_BUIL[ ecl] + EXP_AUTO[ ecl]
   
   # eq en valeur
   
   PENER[ ecl] * ENER[ ecl] = PENER_BUIL[ ecl] * ENER_BUIL[ ecl] + PEXP_AUTO[ ecl] * EXP_AUTO[ ecl]
   
   # Equation H.4.134, H.4.135, and H.4.136
   
   ENER            = @elem(PENER_BUIL, %baseyear) * ENER_BUIL + EXP_AUTO
   
   PENER * ENER = PENER_BUIL * ENER_BUIL + PEXP_AUTO * EXP_AUTO
   
   ENER         = @elem(PENER_BUIL, %baseyear) * ENER_BUIL + EXP_AUTO
   
   PENER * ENER = PENER_BUIL * ENER_BUIL + PEXP_AUTO * EXP_AUTO
   
   
   
   # equation H.4.
   # EMARQUE: 13_OTH provenant des investissement des ménage autres que travaux de rénovation Rajouté au dépenses de consommation courante:EXP_HH_VAL_{%hous})
   
   EXP_OTH_Val = sum(PEXP[co] * EXP[co] on co)
   
   EXP_HH_VAL = EXP_HOUSING_Val + EXP_MOB_Val + EXP_OTH_Val + EXP_13_OTH_Val
   
   
    # marginal propension to save
    # WARNING: $h could need to be offset by 1 when multiple households
    
    d(MPS_HH) = household(52, $h) * d(UNR_TOT) + household(53, $h) * d(R - infl_FR) + household(54, $h) * d(DEBT_G_VAL / (PGDP * GDP))
    
    # Endogenous Marginal Propensity to save
    
    #@over MPS_HH = 0.1 * d(log(DISPINC_VAL{-1} / PCH{-1})) + 0.005 * d(UNR_TOT) + 0.003 * d(R - infl_fr)
    
    S_HH  = DISPINC_VAL - EXP_HH_Val
    
    TS_HH =  S_HH / DISPINC_VAL
    
    S_HH = (DISPINC_VAL - EXP_HH_Val) 
            
    TS_HH = S_HH / DISPINC_VAL 
    
    d(R_I_REHAB[ ecl])   = d(R)
    
    d(R_I_NewBUIL[ ecl]) = d(R)
    
    d(R_I_BUIL[ ecl])    = d(R)
    
    d(R_I_AUTO[ ecl])    = d(R)
    
    # Exception regarding MTEP/CO2EMS
    
    # Carbon intentity endogenous
    
    IC[22,s] = PhiY_ener[22, 2201]    #modifié Gaël
    
    IC[24,s] = PhiY_ener[24, 2401]    #modifié Gaël
    
    IC_HH[22] = PhiY_ener[22, 2201]  #modifié Gaël
                                      
    IC_HH[24] = PhiY_ener[24, 2401]    #modifié Gaël
    
    # Emission linked to internal uses of the branche
    
    @over d(log(EMS_SEC[22,2201])) = (@year>%baseyear)*d(log(Q_Mtep_int[22,2201])) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1))
    
    # household's emissions per source
    
    @over  d(log(EMS_HH[ce2])) = (@year>%baseyear)*dlog((Q_Mtep_H_Buil[ce2]+Q_Mtep_H_AUTO[ce2])*IC_HH[ce2]) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1)) if EMS_HH[ce2] <> 0     #modifié Gaël
    
    # sector's emissions for energy and non energy uses
    
    dlog(EMS_SEC_indus[ce2,s]) = dlog(Q_Mtep_indus[ce2,s])  if EMS_SEC_indus[ce2,s]<>0   # modifié Gaël
      
    # for energy and non energy uses
    
      EMS_SEC_tot[ce2,s] = EMS_SEC[ce2,s] + EMS_SEC_indus[ce2,s]     # modifié Gaël
        
      EMS_SEC_tot[s] = sum(EMS_sec_tot[ce2,s] on ce2)                   # modifié Gaël
      
      EMS_SEC_tot = sum(EMS_sec_tot[s] on s)                            # modifié Gaël
    
    
    ### We should also include the following equation. But this would require reformulating the calculation of the
    ### different PhiY. We neglet this since EMS_SEC[24,2201] represent only 0.7% of the emission of sector 2201
    ### we therefore keep the orginal formulation: d(log(EMS_SEC[ce2,s])) = d(log(E[ce2,s]*IC[ce2,s]))
    ### @over d(log(EMS_SEC[24,2201])) = d(log(Q_Mtep_int[24,2201]))
    
    @over d(log(EMS_SEC[24,2401])) = (@year>%baseyear)*d(log(Q_Mtep_int[2401])) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1))
    
    # Share of energy commodities produced by energy sectors (national account definition)
    
    PhiY[ce, se] = PhiY_ef_tot[ce, se] * (1 - (sum(PhiY[ce, sne] if PhiY[ce, sne] <> 0 on sne))) if PhiY[ce, se] <> 0
    
    verif_PhiY[ce] = sum(PhiY[ce, s] if PhiY[ce, s] <> 0 on s) - 1
    
    # Share of final energy production (including fuel for industrial use)
    
    PhiY_ef_tot[ce, se] = Q_Mtep_ef_tot[ce,se]/Q_Mtep_ef_tot_SOU[ce] if PhiY_ef_tot[ce, se] <> 0
    
    Q_Mtep_ef_tot_SOU[ce] = sum(Q_Mtep_ef_tot[ce,se] on se)
    
    # Final energy share of energy commodities produced by energy sectors
    
    verif_PhiY_ef_tot[ce] = sum(PhiY_ef_tot[ce, se] if PhiY_ef_tot[ce, se] <> 0 on se) - 1
    
    # ***ENERGY PRODUCTION IN MTEP***
    
    # Final energy demand (excluding fuel for industrial use)
    
    Q_Mtep_ef[ce,se] = Q_Mtep_ef_SOU[ce] * PhiY_ener[ce, se] if PhiY_ener[ce, se] <> 0
    
    #-----------------------------Energy consumption in Mtep by use -----------------------------
    
    # Energy demand of Household by use
    
    d(log(Q_Mtep_H_BUIL[ce])) = (@year>%baseyear)*d(log(EXP_BUIL[ce])) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1)) if EXP_BUIL[ce] <> 0 
    
    d(log(Q_Mtep_H_AUTO[ce])) = (@year>%baseyear)*d(log(EXP_AUTO[ce])) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1)) if EXP_AUTO[ce] <> 0
    
    # Energy demand of sectors    
                                               
    d(log(Q_Mtep_SEC[ce, sne])) = (@year>%baseyear)*d(log(E_oth[ce, sne])) + (@year=<%baseyear)*log(1 + STEADYSTATE(2,1)) if Q_Mtep_SEC[ce, sne] <> 0
    
    #---------------------------------------------------------------------------------------------
    
    
    Q_Mtep_X[ce,se]  = Q_Mtep_X_SOU[ce]  * PhiY_ener[ce, se] if Q_Mtep_X[ce,se] <> 0
    
    Q_Mtep_ef_SOU[ce] = Q_Mtep_H_BUIL[ce] + Q_Mtep_H_AUTO[ce] + Q_Mtep_SEC_SOU[ce]
    
    d(log(Q_Mtep_X_SOU[ce])) = d(log(X[ce])) if Q_Mtep_X_SOU[ce] <> 0
    
    # Energy production for non-energy/indus use
    ### For sector 8 (petrochemistry):  plastic made with petrol and fertilizer made with natural  gas;
    ### For sector 10 (steal): coal to make steal
    ### The reason for showing these is that most policy to reduce CO2 emmissions do not target emission from
    ### fuel for on-energy use.
    
    d(log(Q_Mtep_indus[ce,sne])) = d(log(E_indus[ce,sne])) if Q_Mtep_indus[ce,sne] <> 0
    
    # Energy internal uses and losses of the energy producers
    
    Q_Mtep_int[ce,se] = coef_int[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_int[ce,se] <> 0    # modifié
    
    Q_Mtep_Losses[ce,se] = coef_Losses[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_Losses[ce,se] <> 0     # modifié
    
    
    # Energy Production in total final energy (including "energy"/fuel for non-energy/indus use)
    
    Q_Mtep_ef_tot[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_Nener[ce,se] if  Q_Mtep_ef_tot[ce,se] <> 0
    
    Q_Mtep_Nener[ce,se] =  Q_Mtep_indus[ce]*PhiY_indus[ce,se]
    
    Q_Mtep_Nener[ce] =  Q_Mtep_indus[ce]
    
    # Energy Production in primary energy (for energy use)
    
    Q_Mtep_ep[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_int[ce,se] + Q_Mtep_Losses[ce,se] if Q_Mtep_ep[ce,se] <> 0
    
    # Agregations of Q_Mtep
    
    Q_Mtep_|V|[se] = sum(Q_Mtep_|V|[ce,se] if Q_Mtep_|V|[ce,se] <> 0 on ce) if Q_Mtep_|V|[se] <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_|V| = sum(Q_Mtep_|V|[se] if Q_Mtep_|V|[se] <> 0 on se) if Q_Mtep_|V| <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_indus[ce] = sum(Q_Mtep_indus[ce,sne] on sne)   
    
    Q_Mtep_H_BUIL = sum(Q_Mtep_H_BUIL[ce] on ce)
    
    Q_Mtep_H_AUTO = sum(Q_Mtep_H_AUTO[ce] on ce)
    
    Q_Mtep_SEC_SOU[ce] = sum(Q_Mtep_SEC[ce, sne] on sne)
    
    Q_Mtep_SEC[sne] = sum(Q_Mtep_SEC[ce, sne] on ce)
    
    Q_Mtep_H = Q_mtep_H_BUIL + Q_mtep_H_AUTO
    
    Q_Mtep_SEC = sum(Q_Mtep_SEC_SOU[ce] on ce)
    
    verif_Q_Mtep_ep = Q_Mtep_ef + Q_Mtep_Losses + Q_Mtep_int + Q_Mtep_X - Q_Mtep_ep
    
    verif_Q_Mtep_ef_SOU[ce] = sum(Q_Mtep_ef[ce,se] on se) - Q_Mtep_ef_SOU[ce]
    
    verif_Q_Mtep_X_SOU[ce] = sum(Q_Mtep_X[ce,se] on se) - Q_Mtep_X_SOU[ce]
    
    Verif_Q_Mtep_HSEC = Q_Mtep_H + Q_Mtep_SEC - Q_Mtep_ef
    
    # Exception for energy (Distinction between energy indus / other)
    
    #CU_oth[s]*Y[s] = CK[s]*K[s] + CL[s]*L[s]*PROG_L[s] + PE[s]*E_oth[s] + PMAT[s]*MAT[s] if Y[s] > 0
    
    # E_oth[s]: energy used within sector s for energy purposes (ex: electricity for steel making)
    
    d(log(E_oth_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E[s])) if E_oth_n[s] <> 0
    
    # E_indus[s]: energy carrier used within sector s for non-energy purposes (ex: petrochemical feedstock)
    
    d(log(E_indus_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E_indus[s])) if E_indus_n[s] <> 0     #modifié
    
    # Ajustment of E_oth[s] and E_indus[s]
    
    log(|V|[s]) = ADJUST(2 + $V, 1) * log(|V|_n[s]) + (1 - ADJUST(2 + $V, 1)) * (log(|V|[s]{-1}) + d(log(|V|_e[s]))) if |V|[s] <> 0 where V in E_oth E_indus, s in %list_sec
    
    # E_oth[s] = sum( E_oth[ce, s] on ce )
    
    # E_indus[s] = sum( E_indus[ce, s] on ce )
    
    d(log(|V|_e[s])) = ADJUST(2 + $V, 2) * d(log(|V|_e[s]{-1})) + ADJUST(2 +$V, 3) * d(log(|V|[s]{-1})) + ADJUST(2 + $V, 4) * d(log(|V|_n[s])) if |V|[s] <> 0 where V in E_oth E_indus
    
    # equation 2.20
    
    d(log(E_indus[ce, s])) = d(log(E_indus[s])) + d(SUBST_E[ce, s]) if E_indus[ce, s] <> 0
    
    d(log(E_oth[ce, s])) = d(log(E_oth[s])) + d(SUBST_E[ce, s]) if E_oth[ce, s] <> 0
    
    E_indus_SOU[ce] = sum( E_indus[ce, s] on s )
    
    E_oth_SOU[ce] = sum( E_oth[ce, s] on s)
    
    # Internal energy use in energy producing sectors
    
    E_oth_SOU_ener[ce] = sum(E_oth[ce, se] on se)
    
    # Internal energy use in non-energy producing sectors
    
    E_oth_SOU_non_ener[ce] = sum(E_oth[ce, sne] on sne)
    
    @over E[ce, s] = E_indus[ce, s] + E_oth[ce, s] if E[ce, s] <> 0
    
    @over E[s] = E_indus[s] + E_oth[s]  if E[s] <> 0
    
    verif_E[s] = sum( E[ce, s] on ce ) - E[s] if E[s] <> 0
    
    # Exception for the households block
    
    #@over EXP_13 = ( @year > %baseyear ) * ( @elem(PNewBUIL,%baseyear) * NewBUIL + @elem(PREHAB,%baseyear) * REHAB +   _
                                          #EXP_13_OTH_Val / PEXP_13 ) +( @year <= %baseyear ) * (EXP_13{-1} * ( 1 + STEADYSTATE(2,1) ) )
   # 
   #
   @over EXP_13 = ( @year > %baseyear )*( @elem(PNewBUIL,%baseyear) * NewBUIL + (sum(@elem(PREHAB[ecl],%baseyear) * REHAB[ecl] on ecl)) +EXP_13_OTH_Val / PEXP_13 ) + ( @year <= %baseyear ) * (EXP_13{-1} * ( 1 + STEADYSTATE(2,1) ) )

  #@over EXP_13 = ( @elem(PNewBUIL,%baseyear) * NewBUIL + (sum(@elem(PREHAB[ecl],%baseyear) * REHAB[ecl] on ecl)) +EXP_13_OTH_Val / PEXP_13 ) 
       
    @over EXP_03 = ( @year > %baseyear )*(sum(@elem(PAUTO_elec[pcl], %baseyear) * NewAUTO_elec[pcl] on pcl)+ sum(@elem(PNewAUTO_th[ecl], %baseyear) * NewAUTO_th[ecl] on ecl) + EXP_03_OTH_val / PEXP_03) + _
                      ( @year <= %baseyear ) * (EXP_03{-1} * ( 1 + STEADYSTATE(2,1) ) )
    
    
    
    @over d(log(EXP[trsp]))   = d(log(Km_traveler[trsp]))  if Km_traveler[trsp] <> 0 where trsp in %list_trsp_travel
   
        
    
  # --------aggregation dépenses d'énergie par source
  # Equation H.4.137
  
  @over EXP[ce] = @elem(PENER_BUIL[ ce], %baseyear) * ENER_BUIL[ ce] + EXP_AUTO[ ce]
  
  # Equation H.4.138
  
  
  
  # -----------------------------------------------Households expenditures --------------------------------
  # equation H.4.139
  
  @over d(log(NEXP[co])) = (@year >  %baseyear) * d(log(Pop_TOT)) + (@year <=  %baseyear) * log( 1 + STEADYSTATE(2,1))  where co in 01
  
  ###
  ## Equation that completely changes the behaviour of the model on FF shocks 
 
   
 @over EXP_n[c]  = EXP[c]  if EXP[c] <> 0        # modifié 
                          
  
 @over EXP_n[co] = (PEXP[co] * NEXP[co] + BetaExp[co] * (DISPINC_VAL * (1 - MPS_HH) - PNEXP * NEXP - EXP_HOUSING_Val - Exp_13_OTH_VAL - EXP_MOB_Val)) _
                        / PEXP[co]   if EXP[co] <> 0
                        
  
  # equation H.4.140
  # Careful: including this but not the above is not coherent
  
  @over d(log(BetaExp[co])) = (1 - ES_LES_CES(1, 1)) * d(log(PEXP[co] / PEXP_CES)) if BetaExp[co] <> 0
  
  
  # equation H.4.141
  # PEXP_CES is only calculated on other commodities (while all commodities are included in master),
  # excluding vehicles (03), construction (13), road transportation (14, 15) and energies
  
  @over PEXP_CES = (sum(@elem(BetaExp[co], %baseyear) * PEXP[co] ^ (1 - ES_LES_CES(1,1)) on co)) ^ (1 / (1 - ES_LES_CES(1,1)))
  
  
  # equation H.4.142
  
  @over PNEXP * NEXP = sum(PEXP[co] * NEXP[co] on co)
  
  # equation H.4.143
  
  @over NEXP = sum(NEXP[co] on co)
  
  # equation H.4.145
  
  @over EXP[co] = sum(EXP[co] if EXP[co] <> 0 on h)
  
  # equation H.4.146 PROBLEM! Why this equation?
  
  @over Phi_EXP[co] = EXP[co] / EXP[co] if EXP[co] <> 0
  
  # equation H.4.147
  
  @over PEXP[co] = PCH[co]
  
  @over d(log(PEXP[c])) = d(log(PCH[c])) where c in 03 13 14 15 18 21 22 23 24
  
  # equation H.4.150  H.4.151
  
  @over log(EXP[co]) =      ADJUST(20 + $h + %nb_households * ($co - 1), 1)  *  log(EXP_n[co]) +                         _
                    (1 - ADJUST(20 + $h + %nb_households * ($co - 1), 1)) * (log(EXP[co]{-1}) + d(log(EXP_e[co]))) _
                    if EXP[co] <> 0
  
  @over d(log(EXP_e[co])) = ADJUST(20 + $h + %nb_households * ($co - 1), 2) * d(log(EXP_e[co]{-1})) + _
                         ADJUST(20 + $h + %nb_households * ($co - 1), 3) * d(log(EXP[co]{-1})) +   _
                         ADJUST(20 + $h + %nb_households * ($co - 1), 4) * d(log(EXP_n[co]))       _
                         if EXP[co] <> 0
  
  @over d(Stock_S) = S_HH
 
#*********************************************************************************************************************************
#*****************************************************TRANSPORTS******************************************************************

#-----------------------------------------------------AUTOMOBILE-----------------------------------------------------------------

# Equation H.4.78

AUTO_elec[DES,pcl] = (@year>%baseyear)*(delta_AUTO[CA,DES] * AUTO_elec[pcl]{-1}) + (@year<=%baseyear)*AUTO_elec[DES,pcl]{-1}*(1+STEADYSTATE(2,1))        

AUTO_th[DES,ecl] = (@year>%baseyear)*(delta_AUTO[ecl,DES] * AUTO_th[ecl]{-1})+ (@year<=%baseyear)*AUTO_th[DES,ecl]{-1}*(1+STEADYSTATE(2,1))          

AUTO[DES,ecl] = (@year>%baseyear)*(AUTO_th[DES,ecl]) + (@year<=%baseyear)*AUTO[DES,ecl]{-1}*(1+STEADYSTATE(2,1)) 

@over AUTO[DES,CA] = (@year>%baseyear)*(sum(AUTO_elec[DES,pcl] on pcl) + AUTO_th[DES,CA]) + (@year<=%baseyear)*AUTO[DES,CA]{-1}*(1+STEADYSTATE(2,1))           

AUTO[DES] = (@year>%baseyear)*(sum(AUTO[DES,ecl] on ecl)) + (@year<=%baseyear)*AUTO[DES]{-1}*(1+STEADYSTATE(2,1))                    #modifié

# Equation H.4.79 and H.4.80

NewAUTO[CA] = NewAUTO_elec + NewAUTO_th[CA]   #modifié

NewAUTO[c] = NewAUTO_th[c]  where c in %list_ener_class \ CA

# Verif

AUTO_verif = sum( AUTO[ecl] on ecl )


Verif_AUTO = AUTO_verif - AUTO

Verif_AUTO2 = ( @year > %baseyear ) * (NewAUTO - AUTO_DES - d(AUTO)) + ( @year <= %baseyear ) * Verif_AUTO2{-1}


# Equation H.4.81

EXP_MOBAUTO_Val[ecl] = ( @year > %baseyear ) * (DEBT_AUTO_Val[ecl]{-1} * ( R_I_AUTO[ecl]{-1} + R_RMBS_AUTO[ecl]{-1} ) +   _
                                R_CASH_AUTO[ecl] * PNewAUTO[ecl] * NewAUTO[ecl] * ( 1 - R_SUB_AUTO[ecl] ) +       _
                                PEXP_AUTO[ecl] * EXP_AUTO[ecl] ) +                                                    _
                         ( @year <= %baseyear ) * (EXP_MOBAUTO_Val[ecl]{-1} * ( 1 + STEADYSTATE(1,1) ) )

R_LOAN_AUTO[ecl] = 1 - R_CASH_AUTO[ecl]

GR_PENER_auto_e[ecl] = ADJUST(73,2)*GR_PENER_auto_e[ecl]{-1} + (1 - ADJUST(73,2)) * @pchy(PENER_auto[ecl])

#phi_NewAUTO[CA]*NewAUTO = share_elec*NewAUTO + phi_th[CA]*NewAUTO_th        

#phi_NewAUTO[c] = phi_th[c]   where c in %list_ener_class \CA

PENER_AUTO[ecl] * KM_AUTO[ecl] = PEXP_AUTO[ecl] * EXP_AUTO[ecl] if AUTO[ecl] <> 0
  
# Equation H.4.83

DEBT_auto_Val[ecl] = (@year > %baseyear)*( DEBT_auto_Val[ecl]{-1}*(1 - R_RMBS_AUTO[ecl]) _
                                             + R_LOAN_AUTO[ecl]*PNewAuto[ecl]*NewAuto[ecl]*(1 - R_SUB_AUTO[ecl]) ) _
                       + (@year <= %baseyear)*(DEBT_auto_Val[ecl]{-1}*(1 + STEADYSTATE(1,1)))

# Equation H.4.84

EXP_NEWAUTO_VAL[ecl] = PNewAuto[ecl] * NewAUTO[ecl]

# Equation H.4.88

dlog(AUTO)= (@year > %baseyear)*(d(log(Km_auto))-d(log(kmPerAuto))) + _
              (@year <= %baseyear)*log(1+STEADYSTATE(2,1))                                     #modifié

# Equation H.4.89 and H.4.90

KM_AUTO[ecl] = sum(km_AUTO[ ecl, ce] on ce)    #modifié

dlog(EXP_AUTO[ecl,ce2]) = d(log(AUTO_th[ecl,ce2])) -dlog(PROG_AUTO)  if AUTO_th[ecl,ce2] <> 0   #modifié

EXP_AUTO[CA,23] = sum(EXP_AUTO_elec[pcl] on pcl)                                             #modifié

EXP_AUTO[c,23] = 0   where c in %list_ener_class \CA                                           #modifié


# -------------------------------------------Aggregation of automobile expenditure--------------------------------------------
# Equation H.4.91

EXP_AUTO[ecl] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ce )

PEXP_AUTO[ecl]*EXP_AUTO[ecl] = sum( PEXP[ce]*EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ce )      # corrigé

# Equation H.4.92

@pv EXP_AUTO = sum( EXP_AUTO[ecl] if EXP_AUTO[ecl] <> 0 on ecl )

EXP_AUTO[ce] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ecl )

# Equation H.4.93

EXP_AUTO[ce] = sum( EXP_AUTO[ecl,ce] if EXP_AUTO[ecl,ce] <> 0 on ecl )


# -----------------------------------------------------------AGGREGATION AUTOMOBILE---------------------------------------------------

# Equation H.4.97
AUTO = sum(AUTO[ecl] on ecl)

# Equation H.4.98

NewAUTO = (@year>%baseyear)*(d(AUTO) + AUTO[DES]) + (@year<=%baseyear)*(NewAUTO{-1}*(1+STEADYSTATE(2,1)))  #  modifié

 # Equation H.4.99
 @over PnewAUTO*NewAUTO = PAUTO_elec*NewAUTO_elec + PNewAUTO_th*NewAUTO_th  if NewAUTO>0         #modifié
 
# Equation H.4.100
EXP_NEWAUTO_VAL = sum(EXP_NewAUTO_VAL[ ecl] on ecl)


# Equation H.4.102

phi_exp_03bis = EXP_NEWAUTO_VAL / EXP_NEWAUTO_VAL

# Equation H.4.103

EXP_MOBAUTO_Val = sum(EXP_MOBAUTO_Val[ ecl] if EXP_MOBAUTO_Val[ ecl] <> 0 on ecl)


# Equation H.4.107 and H.4.108

d(log(EXP_03_OTH_VAL)) = d(log(DISPINC_VAL)) + d(log(1 - MPS_HH))

# ------------------------------------------------------TRANSPORT COLLECTIF--------------------------------------------------------------
# Equation H.4.113

EXP_MOB_OTH_Val = sum(PEXP[trsp] * EXP[trsp] on trsp in %list_trsp_travel)

# ---------------------------------------------------------Total mobility---------------------------------------------------
# Equation H.4.117

EXP_MOB_Val = EXP_MOBAuto_Val + EXP_MOB_OTH_Val + EXP_03_OTH_VAL


 # Modal shift in transportation
 
@over d(log(MAT[16, s])) = d(log(MAT[s])) + d(SUBST_MAT[16, s]) + log(1 -  modal_shift_freight * (1 + 1/4) * MAT[16, s]{-1} / MAT[16, s]{-1}) if MAT[16, s] <> 0

@over d(log(MAT[14, s])) = d(log(MAT[s])) + d(SUBST_MAT[14, s]) + log(1 +  modal_shift_freight             * MAT[16, s]{-1} / MAT[14, s]{-1}) if MAT[14, s] <> 0

@over d(log(MAT[17, s])) = d(log(MAT[s])) + d(SUBST_MAT[17, s]) + log(1 + (modal_shift_freight / 4)        * MAT[16, s]{-1} / MAT[17, s]{-1}) if MAT[17, s] <> 0
 
# Aspect sobriété dans l'automobile et efficacité énérgetique     modifié
 # Equation H.4.89 and H.4.90

AUTO[ecl,ce] = AUTO[ecl]*SHARE_AUTO[ecl,ce]      

AUTO[ce] = sum(AUTO[ce] on h)

SHARE_AUTO[CA,23] = AUTO_elec/AUTO[CA]

SHARE_AUTO[ c, 23] = 0      where c in %list_ener_class \ CA

SHARE_AUTO[CA,ce2] = (1-SHARE_AUTO[CA,23])*@elem(AUTO[CA,ce2]/(AUTO[CA,21] +AUTO[CA,22]+AUTO[CA,24]),%baseyear)  

# Subventions automobile ( Bonus-malus auto + bonus elec)

SUB_AUTO_VAL[ ecl] = R_SUB_AUTO[ ecl]*PNewAUTO[ ecl] * NewAUTO[ ecl]

SUB_AUTO_VAL = sum(SUB_AUTO_VAL[ecl] on ecl)


###########Niveau 1 : Détermination du nombre de km pour l'avion, les trajets longue distance et les trajets courte distance       modifié

 ## passager-kilomètre Avion 
 
 @over d(log(Km_traveler[18])) =(@year>%baseyear)*(1.5*d(log(dispinc_val/PCH))-0.7*d(log(PCH_18)-log(PCH))) + _
                                   (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
      
 ## passager-kilomètre Longue distance
 
 d(log(km_traveler_LD)) =(@year>%baseyear)*(0.6*d(log(dispinc_val/PCH)) -0.4*((km_traveler_14{-1}/( km_traveler_14{-1}+ km_trav_auto_LD{-1})) _
                             *d(log(pc_trav_14/PCH)))  + sobre_AUTO_LD *(km_trav_auto_LD{-1}/(km_traveler_14{-1}+ km_trav_auto_LD{-1})) _
                             * dlog( PC_trav_auto_LD/PCH)) + (2006<@year)*(@year<2016)*trend_km_traveler_LD + _
                             (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
 
 ## passager-kilomètre courte distance
 
 d(log(km_traveler_CD)) =(@year>%baseyear)*(0.4*d(log(dispinc_val/PCH)) -0.3*(km_traveler_15{-1}/( km_traveler_15{-1}+ km_trav_auto_CD{-1})) _
                             *dlog(pc_trav_15/PCH) + sobre_AUTO_CD*dlog(PC_trav_auto_CD/PCH) * km_trav_auto_CD{-1}/(km_traveler_15{-1}+ km_trav_auto_CD{-1})) _
                             + (2006<@year)*(@year<2016)*trend_km_traveler_CD + _
                             (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
 
 
 ############### Niveau 2 : arbitrages CES           modifié
 
 ## Arbitrage longue distance : fer et VP(courte distance)
 
 #Fer 
 
 @over dlog(km_traveler_14)=(@year > %baseyear)*(d(log(km_traveler_LD))+ _
                                  0.5*(km_trav_auto_LD{-1}/(km_traveler_14{-1}+km_trav_auto_LD{-1}))*d(log(PC_trav_auto_LD)-log(pc_trav_14)))+ _
                                   (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
 
 #VP longue distance
 
 dlog(km_trav_auto_LD)=(@year > %baseyear)*(d(log(km_traveler_LD))+ _
                           0.5*(km_traveler_14{-1}/(km_traveler_14{-1}+ km_trav_auto_LD{-1}))* d(log(pc_trav_14)-log(PC_trav_auto_LD))) + _
                           (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
    
 ## Arbitrage courte distance : Bus et VP (courte distance)
 
 #VP courte distance 
 
 dlog(km_trav_auto_CD)=(@year > %baseyear)*(d(log(km_traveler_CD))+ _ 
                         0.2*(km_traveler_15{-1}/(km_traveler_15{-1}+ km_trav_auto_CD{-1}))* d(log(pc_trav_15)-log(PC_trav_auto_CD))) + _
                         (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
 
 # Bus
 
 @over dlog(km_traveler_15)=(@year > %baseyear)*(d(log(km_traveler_CD))+ _ 
                                 0.2*(km_trav_auto_CD{-1}/( km_traveler_15{-1}+ km_trav_auto_CD{-1}))*d(log(PC_trav_auto_CD)-log(pc_trav_15)))+ _
                               (@year<=%baseyear)*log(1+STEADYSTATE(2,1))
 
 
 
############### Auto     modifié
## km réalisés en voiture : 
#Longue distance

d(log(km_auto_LD))  =d(log(km_trav_auto_LD))-d(log(travperauto_LD))

#Courte distance

d(log(km_auto_CD))=d(log(km_trav_auto_CD))-d(log(travperauto_CD))

#Nombre total de kilomètres en auto

KM_AUTO= km_auto_LD+km_auto_CD

#Nombre d'autos

AUTO[ce]=sum(AUTO[ecl,ce] on ecl)


################ Coût du transport au km VP nouvelle version :   modifié

p_mobauto_val*km_auto = exp_mobauto_val*1000

d(log(PC_trav_auto_LD)) = d(log(p_mobauto_val))-d(log(travperauto_LD))

d(log(PC_trav_auto_CD)) = d(log(p_mobauto_val))-d(log(travperauto_CD))

################Coût du transport au km en transports en commun     modifié

PC_trav_14*km_traveler_14 = pch_14*ch_14

PC_trav_15*km_traveler_15 = pch_15*ch_15


# Dans cette exception, nous allons redéfinir le parc auto en ajoutant une spécification spéciale pour les véhicules électriques.
# L'idée est d'effectuer un choix de véhicules en deux étapes : 1 : choix entre électrique et thermique, 2 : choix de la classe d'énergie en fct des gCO2/km pour le thermique et des kWh/km pour l'elec.

##AUTOS ELECTRIQUES         modifié

dlog(KM_AUTO_elec[pcl]) = dlog(AUTO_elec[pcl]) - dlog(KmPerAuto)

KM_AUTO_elec = sum(KM_AUTO_elec[pcl] on pcl) 

d(AUTO_elec)=(@year>%baseyear)*(NewAUTO*share_elec-delta_AUTO[CA,DES]*AUTO_elec{-1})+ _
                (@year <= %baseyear) * (AUTO_elec{-1} * (STEADYSTATE(2,1) ) )

d(AUTO_elec[pcl])= (@year>%baseyear)*(NewAUTO*share_elec*phi_elec[pcl]-delta_AUTO[CA,DES]*AUTO_elec[pcl]{-1}) + _
                      (@year <= %baseyear) * (AUTO_elec[pcl]{-1} * (STEADYSTATE(2,1) ) )

NewAUTO_elec = NewAUTO*share_elec

NewAUTO_th = NewAUTO*(1-share_elec)

NewAUTO_th[ ecl] = NewAUTO_th*phi_th[ecl]

NewAUTO_elec[pcl] = NewAUTO_elec*phi_elec[pcl]
  
d(AUTO_th[ecl])= (@year>%baseyear)*(NewAUTO*(1-share_elec)*phi_th[ecl]-delta_AUTO[ecl,DES]*AUTO_th[ecl]{-1}) + _
                  (@year <= %baseyear)*(AUTO_th[ecl]{-1} * (STEADYSTATE(2,1) ) ) 

AUTO[CA] =  AUTO_th[CA] + AUTO_elec         #modifié

AUTO[c] =  AUTO_th[c]   where c in %list_ener_class \ CA

## prix d'achat du véhicule

PAUTO_elec[pcl] = PNewAUTO_th[pcl]+(Pbattery + overcost_elec)/1000

PAUTO_elec*NewAUTO_elec = sum(PAUTO_elec[pcl]*NewAUTO_elec[pcl] on pcl)

PNewAUTO[CA]*NewAUTO[CA] = PAUTO_elec*NewAUTO_elec + PNewAUTO_th[CA]*NewAUTO_th[CA] if  NewAUTO[CA]>0

dlog(PNewAUTO_th[ecl]) =dlog(PCH_03)

PNewAUTO[c] = PNewAUTO_th[c]  where c in %list_ener_class \ CA

PNewAUTO_th*NewAUTO_th = sum(PNewAUTO_th[ ecl] * NewAUTO_th[ ecl] on ecl)  if NewAUTO_th>0

##Coût d'usage énergétique du véhicule

dlog(PENER_AUTOelec[pcl]) = dlog(pch[23]) + dlog(EXP_AUTO_elec[pcl]) - dlog(AUTO_elec[pcl])

dlog(EXP_AUTO_elec[pcl]) = dlog(KM_AUTO_elec[pcl]) - dlog(prog_auto_elec) 

###coût d'usage annualisé de l'énergie

UC_E_auto_elec[pcl]=PENER_autoelec[pcl] #*((1+dlog(PCH))^(AUTO_elec_D[pcl])-1)/(dlog(PCH)*AUTO_elec_D[pcl])
		
R_SUB_AUTO_elec[pcl]= bonus_elec/PAUTO_elec[pcl]

R_SUB_AUTO_elec = sum(R_SUB_AUTO_elec[pcl]*phi_elec[pcl] on pcl )
 		
R_SUB_AUTO_th[ecl]= bonus_th[ecl]/Pnewauto_th[ecl]
 
R_SUB_AUTO[CA]*NewAUTO[CA] = (R_SUB_AUTO_elec*NewAUTO_elec + R_SUB_AUTO_th[CA]* NewAUTO_th[CA]) if NewAUTO[CA]>0

#R_SUB_AUTO[c]*NewAUTO[c] = R_SUB_AUTO_th[c]* NewAUTO_th[c]  where c in %list_ener_class \ CA  if NewAUTO[c]>0

R_SUB_AUTO[c] = R_SUB_AUTO_th[c]  where c in %list_ener_class \ CA  if NewAUTO[c]>0

R_SUB_AUTO_th*NewAUTO_th = sum(R_SUB_AUTO_th[ecl]*NewAUTO_th[ecl] on ecl )  if NewAUTO_th>0

R_SUB_AUTO = R_SUB_AUTO_th*(1-share_elec) + R_SUB_AUTO_elec*share_elec

###coût d'achat annualisé du véhicule électrique (payé en partie grâce à l'emprunt)

UC_K_auto_elec[pcl] = ((PAUTO_elec[pcl]) / AUTO_elec_D[pcl] ) * ( 1 - R_SUB_AUTO_elec[pcl] ) * (  R_CASH_AUTO_elec[pcl] + _
    R_LOAN_AUTO_elec[pcl] * R_I_AUTO_elec[pcl]{-1} * LD_AUTO_elec[pcl] / ( 1 - ( 1 + R_I_AUTO_elec[pcl]{-1} )^( - LD_AUTO_elec[pcl] ) ) )

##### FOnction d'utilité, Les coefficients proviennent de l'étude de Isis Durrmeyer "To Rebate or not To Rebate"

U_auto_elec[pcl]=-0.76*UC_K_auto_elec[pcl]-0.2*UC_E_auto_elec[pcl]    

d(phi_elec_n[pcl])= (@year>%baseyear)*d(exp(U_auto_elec[pcl])/(sum(exp(U_auto_elec[c]) where c in %list_price_class)))      

phi_elec_n_tot= sum(phi_elec_n[pcl] if  phi_elec_n[pcl]>0 on pcl)   

phi_elec[pcl] = (phi_elec_n[pcl]>0)*phi_elec_n[pcl]/phi_elec_n_tot + (phi_elec_n[pcl]<=0)*0

#####Définition du coût de maintenance (hors batterie) du véhicule électrique:

UC_M_auto_elec=(HOUSEHOLD_HYBRID_AUTO(218,1)*PCH_03/100*km_auto/auto)/1000 

UC_auto_elec = sum(@elem(phi_elec[pcl],%baseyear)* (UC_K_auto_elec[pcl] + UC_E_auto_elec[pcl]) on pcl) + UC_M_auto_elec 

#### AUTOS THERMIQUES          modifié

dlog(KM_AUTO_th[ecl]) = dlog(AUTO_th[ecl]) - dlog(KmPerAuto) if AUTO_th[ecl]>0

KM_AUTO_th = sum(KM_AUTO_th[ecl] on ecl) 

KM_AUTO[CA,23]= KM_AUTO_elec 

KM_AUTO[c,23]= 0    where c in %list_ener_class \CA 

KM_AUTO[ecl,ce2]= KM_AUTO_th[ecl,ce2]

dlog(KM_AUTO_th[ecl,ce2]) = dlog(AUTO_th[ecl,ce2]) - dlog(KmPerAuto) if AUTO_th[ecl,ce2]>0

dlog(AUTO_th[ecl,ce2]) =  dlog(AUTO_th[ecl])      if AUTO_th[ecl,ce2]>0

AUTO_th[ce2] =  sum(AUTO_th[ecl,ce2] on ecl)

AUTO_th =  sum(AUTO_th[ecl]  on ecl) 

AUTO_th =  sum(AUTO_th  on h)

PENER_AUTO_th[ecl] *AUTO_th[ecl]= pch[22] * EXP_AUTO[ecl,22] + pch[24] * EXP_AUTO[ecl,24] if AUTO_th[ecl] <> 0

UC_E_auto_th[ecl] = PENER_auto_th[ecl] #*((1+dlog(PCH))^(AUTO_D[ecl]) - 1 ) / ( dlog(PCH)*AUTO_D[ecl] ) 
      	
UC_K_auto_th[ecl] = ((Pnewauto_th[ecl]) / AUTO_D[ecl] ) * ( 1 - R_SUB_AUTO_th[ecl] ) * (  R_CASH_AUTO[ecl] +      _
      R_LOAN_AUTO[ecl] * R_I_AUTO[ecl]{-1} * LD_AUTO[ecl] / ( 1 - ( 1 + R_I_AUTO[ecl]{-1} )^( - LD_AUTO[ecl] ) ) )

U_auto_th[ecl]=-0.76*UC_K_auto_th[ecl]-0.2*UC_E_auto_th[ecl]                   

d(phi_th_n[ecl]) = (@year>%baseyear)*d(exp(U_auto_th[ecl])/(sum(exp(U_auto_th[c]) where c in %list_ener_class))) 

phi_th_n_tot = sum(phi_th_n[ecl]  if  phi_th_n[ecl]>0 on ecl)   

phi_th[ecl] = (phi_th_n[ecl]>0) * phi_th_n[ecl]/phi_th_n_tot + (phi_th_n[ecl]<=0)*0    

UC_M_auto_th=(HOUSEHOLD_HYBRID_AUTO(219,1)*PCH_03/100*km_auto_th/(auto-auto_elec))/1000

UC_auto_th = sum(@elem(phi_th[ecl],%baseyear)* (UC_K_auto_th[ecl] + UC_E_auto_th[ecl]) on ecl) + UC_M_auto_th
 
#### cf.hypothèses de l'étude du CGDD #Analyse coûts bénéfices des véhicules électriques" réalisée par Stéphane Taszka et Silvano Domergue. cf; Modèle de Bass (1963)
             
share_th = 1-share_elec

share_elec= phiNVE*(phiNVE<=1) + (phiNVE=1)

share_elec =  share_elec
  
 d(phiNVE)=innovation * (1-phiNVE{-1}) + imitation * (phiNVE{-1}) * (1-phiNVE{-1})
   
 imitation =  coeffBassimit 
   
 innovation = coeffBassinnov 
  
 d(coeffBassinnov) = ES_BASS*d((2*UC_auto_elec)^(-nu_diffusion)/((2*UC_auto_elec)^(-nu_diffusion)+(UC_auto_th)^(-nu_diffusion)))      
  
U_auto_elec * @elem(NewAUTO_elec,%baseyear) = sum(U_auto_elec[pcl] * @elem(NewAUTO_elec[pcl],%baseyear) on pcl)
  
U_auto_th * @elem(NewAUTO_th,%baseyear) = sum(U_auto_th[ecl] * @elem(NewAUTO_th[ecl],%baseyear) on ecl)

  ##-------------------------- sectors' GDP calibration over the 2006-2015 period--------- Modifié 
                                                        
  d(log(WD[cm]))=  (d(log(Xexo[cm])) - d(SUBST_X[cm]) )*(@year<=2015) + log(1+STEADYSTATE(2,1)) *(@year>2015)   if Xexo[cm] <> 0
  
  @over dlog(X[cm]) = (dlog(Xexo[cm]))*(@year<=2015) + (d(log(WD[cm])) + d(SUBST_X[cm])) *(@year>2015)   if X[cm] <> 0
 
  
  @over DSD[cm] = (@year<=2006)* (DS_trend * @elem(DSD[cm], %baseyear) / @elem(DSD + DSM, %baseyear)) + _
                 (@year>2006)*( (QDexo[cm]-CID[cm]-CHD[cm]- GD[cm]-ID[cm] -XD[cm])*(@year<=2015) + (DS_trend * DSD[cm]{-1} /(DSD{-1} + DSM{-1}))*(@year>2015))
  
  #@over DSD[cm] = (DSexo[cm] -DSM[cm])*(@year<=2015) + (DSD[cm]{-1}*(1+dlog(DS_trend)))*(@year>2015)   
 
  @over DSD[ce2] = DS_trend * @elem(DSD[ce2], %baseyear) / @elem(DSD + DSM, %baseyear)
  
  #@over DSM[cm] = (DSMexo[cm]) * (@year<=2015) + (DSM[cm]{-1} * (1+dlog(DS_trend))) * (@year>2015)     
 
  @over DSM[ce2] = DS_trend * @elem(DSM[ce2], %baseyear) / @elem(DSD + DSM, %baseyear)
 
  @over DSM[cm] = (@year<=2006) * (DS_trend * @elem(DSM[cm], %baseyear) / @elem(DSD + DSM, %baseyear)) + _
                   (@year>2006) * ( (QMexo[cm]-CIM[cm]-CHM[cm]- GM[cm]-IM[cm] -XM[cm]) * (@year<=2015) + (DS_trend * DSM[cm]{-1} /(DSD{-1} + DSM{-1}))*(@year>2015))
 
 
  @over EXP_n[co] = (@year <= 2015)*((@year <= %baseyear) * (@elem(EXP_n[co],%baseyear) * (1 + STEADYSTATE(2, 1))^(@year-%baseyear))+ _
                      (@year > %baseyear)*(EXP_n[co]{-1}*EXPexo[co]/EXPexo[co]{-1})) + _
                      (@year >  2015) * ((PEXP[co] * NEXP[co] + BetaExp[co] * _ 
                        (DISPINC_VAL * (1 - MPS_HH) - PNEXP * NEXP - EXP_HOUSING_Val - Exp_13_OTH_VAL - EXP_MOB_Val)) _
                        / PEXP[co])  if EXP[co] <> 0
  
 @over log(EXP[co]) = log(EXP_n[co])*(@year<=2015) + _
                     (ADJUST(20 + $h + %nb_households * ($co - 1), 1)  *  log(EXP_n[co]) _
                     + (1 - ADJUST(20 + $h + %nb_households*($co - 1), 1))*(log(EXP[co]{-1}) + dlog(EXP_e[co])))*(@year>2015)    if EXP[co] <> 0
                     
  @over dlog(EXP_e[co]) = (@year <= 2015)*(dlog(EXP_n[co])) + _
                              (@year > 2015)* (ADJUST(20 + $h + %nb_households * ($co - 1), 2) * d(log(EXP_e[co]{-1})) + _
                              ADJUST(20 + $h + %nb_households * ($co - 1), 3) * d(log(EXP[co]{-1})) +   _
                              ADJUST(20 + $h + %nb_households * ($co - 1), 4) * d(log(EXP_n[co]))) if EXP[co] <> 0
  
  @over dlog(BetaExp[co]) = (@year <= 2015)*(0.000001) + _
                                 (@year > 2015)*((1 - ES_LES_CES(1, 1)) * d(log(PEXP[co] / PEXP_CES))) if BetaExp[co] <> 0                            
  
  #@over EXP_13 = (EXP_13{-1}*EXPexo[13]/EXPexo_13{-1})*(@year<=2015) + _
  #                  (@year>2015)*(( @year > %baseyear )*( @elem(PNewBUIL,%baseyear) _
  #                   * NewBUIL + @elem(PREHAB,%baseyear) * REHAB + EXP_13_OTH_Val / PEXP_13 ))  
  
  #@over dlog(EXP_13_OTH_VAL) = (EXPothexo[13]/EXPothexo_13{-1})*(@year<=2015) + _
  #                                       (@year>2015)*(dlog(DISPINC_VAL) + dlog(1 - MPS_HH)) 
                                        
  @over NewBUIL[ecl] =  (@year <= 2006) * @elem(NewBUIL[ecl],%baseyear)*(1+STEADYSTATE(2,1))^(@year-%baseyear) + _
                          (@year > 2006) *( @year <= 2015 ) * (NewBUIL[ecl]{-1}*NewBUILexo/NewBUILexo{-1}) + _
                          ( @year > 2015 ) * phi_NewBUIL[ecl] * ( d( BUIL ) + BUIL[DES] ) 
                        
                 
  @over BUIL =  (@year<=2006)*(@elem(BUIL,%baseyear) *(1+steadystate(2,1))^(@year-%baseyear)) + _
                    (@year > 2006) *(@year <= 2015) * (BUIL{-1} -BUIL[DES] + NewBUIL ) + _
                   (@year>2015)*(BUIL{-1} *(1+d(POP_tot)/POP_tot{-1} + d(M2perCapita)/M2perCapita{-1}))                  
                  
  #@over EXP_03 = (EXP_03{-1}*EXPexo_03/EXPexo_03{-1})*(@year<=2015) + _
  #                  (@year>2015) * (sum(@elem(PAUTO_elec[pcl], %baseyear) * NewAUTO_elec[pcl] on pcl) + _
  #                  sum(@elem(PNewAUTO_th[ecl], %baseyear) * NewAUTO_th[ecl] on ecl) + EXP_03_OTH_val / PEXP_03)
  
  @over dlog(AUTO)= (@year<=2015)*(dlog(AUTOexo)) + (@year>2015)*(dlog(Km_auto)-dlog(kmPerAuto)) 
  
  #@over dlog(EXP_03_OTH_VAL) = (@year<=2015)*(dlog(EXPothexo_03)) + (@year>2015)*((dlog(DISPINC_VAL) + dlog(1 - MPS_HH)))   
   
  @over dlog(EXP[trsp])   = (dlog(EXPexo[trsp]))*(@year<=2015) + _                                                                           
                                (@year >  2015) * d(log(Km_traveler[trsp])) if Km_traveler[trsp] <> 0 where trsp in %list_trsp_travel
                       
  @over d(MPS_HH) = (@year<=2006)*0 +(@year>2006)*(@year<=2015)*(d((DISPINC_VAL - EXP_HH_Val)/DISPINC_VAL)) + _
                      (@year>2015) * ( household(52, $h) * d(UNR_TOT) + household(53, $h) * d(R - infl_FR) _
                       + household(54, $h) * d(DEBT_G_VAL / (PGDP * GDP)))
  
  @over CHD[cm] = ((EXP[cm]-CHM[cm] > 0) * (EXP[cm] - CHM[cm]) + (EXP[cm] - CHM[cm] =< 0) * (0.00001))*(@year<=2015) + _
                   (CHD[cm]{-1} * (1 + d(EXP[cm])/EXP[cm]{-1} + d(SUBST_CHD[cm])))*(@year>2015)     if CHD[cm] <> 0
                       
  @over CHM[cm] = (CHM[cm]{-1}*(1 + (QMexo[cm]>0)*(d(QMexo[cm])/QMexo[cm]{-1})))*(@year<=2015) _
                   + ((EXP[cm] - CHD[cm]>0)*(EXP[cm] - CHD[cm])+(EXP[cm] - CHD[cm]<=0)*0.00001)*(@year>2015) if CHM[cm] <> 0
  
  @over GD[cm] = ((EXPG[cm] - GM[cm]>0)*(EXPG[cm] - GM[cm])+(EXPG[cm] - GM[cm]<=0)*0.00001)*(@year<=2015) + (GD[cm]{-1}*(1+d(EXPG[cm])/EXPG[cm]{-1} + d(subst_GD[cm])))*(@year>2015) if GD[cm] <> 0          #corrigé
  
  @over GM[cm] = (GM[cm]{-1}*(1+ (QMexo[cm]>0)*(d(QMexo[cm])/QMexo[cm]{-1})))*(@year<=2015) + ((EXPG[cm] - GD[cm]>0)*(EXPG[cm] - GD[cm])+(EXPG[cm] - GD[cm]<=0)*0.00001)*(@year>2015) if GM[cm] <> 0
  
  @over dlog(CIexo[cm,sne])  = dlog(CIexo[cm])  if CIexo[cm,sne] <> 0
  
  @over CIDexo[cm,sne]  = (CIexo[cm,sne] - CIMexo[cm,sne]>0)*(CIexo[cm,sne] - CIMexo[cm,sne])+(CIexo[cm,sne] - CIMexo[cm,sne]<=0)*0.0001   if CIexo[cm,sne] <> 0          
    
  @over dlog(CIMexo[cm,sne])  = dlog(QMexo[cm])     if CIMexo[cm,sne] <> 0
                     
  @over MATD[cm,sne]  = (CIDexo[cm,sne])*(@year<=2015) + _
                        (MATD[cm,sne]{-1}*(1+(MAT[cm,sne]>0)*(d(MAT[cm,sne])/MAT[cm,sne]{-1} + d(SUBST_MATD[cm,sne])))) *(@year>2015) if MATD[cm,sne] <> 0
    
  @over MATM[cm,sne]  = (CIMexo[cm,sne])*(@year<=2015) _
                       + ((MAT[cm,sne]-MATD[cm,sne]>0)*(MAT[cm,sne]-MATD[cm,sne])+(MAT[cm,sne]-MATD[cm,sne]<=0)*0.0001)*(@year>2015) if MATM[cm,sne] <> 0
 
 @over dlog(MAT_n[sne]) = (@year<=2015) * (dlog(sum(MATD[cm,sne] on cm)+sum(MATM[cm,sne] on cm))) + (@year>2015) *(dlog(Y[sne]) + d(SUBST_MAT[sne]) )       if MAT_n[sne] <> 0
 
 @over log(MAT[sne]) =  (@year<=2015) *log(MAT_n[sne]) + (@year>2015)*( ADJUST(4, 1) * log(MAT_n[sne]) + (1 - ADJUST(4, 1)) * (log(MAT[sne]{-1}) + d(log(MAT_e[sne])))) if MAT[sne] <> 0
 
 @over dlog(MAT_e[sne]) = (@year<=2015) *dlog(MAT_n[sne]) + (@year>2015)*( ADJUST(4, 2) * d(log(MAT_e[sne]{-1})) + ADJUST(4, 3) * d(log(MAT[sne]{-1})) + ADJUST(4, 4) * d(log(MAT_n[sne]))) if MAT[sne] <> 0 
 
 @over d(log(MAT[cm, sne])) = (@year<=2015) * (dlog(CIexo[cm,sne])) + (@year>2015) * (dlog(MAT[sne]) + d(SUBST_MAT[cm, sne])) if MAT[cm, sne] <> 0
 
  @over IAD[cm,sne]  = ((IA[cm,sne] - IAM[cm,sne]>0)*(IA[cm,sne] - IAM[cm,sne])+(IA[cm,sne] - IAM[cm,sne]<=0)*0.0001)*(@year<=2015) + _
                        (IAD[cm,sne]{-1}*(1+(IA[cm,sne]>0)*(d(IA[cm,sne])/IA[cm,sne]{-1} + d(SUBST_IAD[cm,sne])))) *(@year>2015) if IAD[cm,sne] <> 0
  
  @over IAM[cm,sne]  = (IAM[cm,sne]{-1} * (1+(QMexo[cm]>0) * (d(QMexo[cm])/QMexo[cm]{-1})))*(@year<=2015) + _ 
                        ((IA[cm,sne]-IAD[cm,sne]>0) * (IA[cm,sne]-IAD[cm,sne])+(IA[cm,sne]-IAD[cm,sne]<=0)*0.0001) * (@year>2015) if IAM[cm,sne] <> 0
 
  @over dlog(IA[sne]) = (@year<=2015) * ((IAexo[sne]>0)*(dlog(IAexo[sne]))) + (@year>2015) * ( ADJUST(1, 1) * dlog(IA[sne]{-1}) + ADJUST(1, 2) * dlog(Y_e[sne]) + _
                          ADJUST(1, 3) * (log(K_n[sne]{-1}) - log(K[sne]{-1})) + ADJUST(1, 4) * d(SUBST_K[sne]))  if IA[sne] <> 0
  
  @over d(log(K_n[sne])) = (@year<=2015) * (K_n[sne]>0)*(dlog(K[sne])) + _
                          (@year>2015) * (dlog(Y[sne]) + d(SUBST_K[sne]) - dlog(PROG_K[sne])) if K_n[sne] <> 0                          
   
 
   ##-------------- public spendings calibration over the 2006_2015 period
 
  
  @over dlog(EXPG[cm]) = dlog(EXPGexo[cm])*(@year<=2015) + (ADJUST(69,1) * (dlog(EXPG_trend) - STEADYSTATE(62,1) * (DP_G_VAL - DP_G_VAL_n) * PGDP(-1) * GDP(-1) / (PG(-1) * EXPG(-1))) + (1 - ADJUST(69,1)) * d(log(EXPG(-1))))*(@year>2015)     if EXPG[cm] <>0
  
  @over EXPG = sum(EXPG[c] on c)

## ------------------------ implicit price signal insertion  
  
   @over d(SUBST_K_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CK[s]) - log(CL[s]))                    * (L[s]{-1}     * PROG_L[s]{-1} * CL[s]{-1}      / (CU[s]{-1} * Y[s]{-1} + E[s]{-1} * PE_Signal[s]{-1})) _
     -eta_K_E[s]     * d(log(CK[s]) - log((PE[s] + PE_Signal[s])))   * (E[s]{-1} * (PE[s]{-1} + PE_Signal[s]{-1}) / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 3) * d(log(CK[s]) - log(PMAT[s]))                  * (MAT[s]{-1}   * PMAT[s]{-1}                    / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if K_n[s] <> 0
   
   @over d(SUBST_E_n[s]) = _
     -eta_K_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CK[s]))   * (K[s]{-1}   * CK[s]{-1}                 / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -eta_L_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CL[s]))   * (L[s]{-1}   * PROG_L[s]{-1} * CL[s]{-1} / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 6) * d(log((PE[s] + PE_Signal[s])) - log(PMAT[s])) * (MAT[s]{-1} * PMAT[s]{-1}               / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if E_n[s] <> 0
   
   @over d(SUBST_L_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CL[s]) - log(CK[s]))                  * (K[s]{-1} * CK[s]{-1}                          / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -eta_L_E[s]     * d(log(CL[s]) - log((PE[s] + PE_Signal[s]))) * (E[s]{-1} * (PE[s]{-1} + PE_Signal[s]{-1}) / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 5) * d(log(CL[s]) - log(PMAT[s]))                * (MAT[s]{-1} * PMAT[s]{-1}                      / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if L_n[s] <> 0
   
   @over d(SUBST_MAT_n[s]) = _
     -ES_KLEM($s, 3) * d(log(PMAT[s]) - log(CK[s]))                * (K[s]{-1} * CK[s]{-1}                          / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 5) * d(log(PMAT[s]) - log(CL[s]))                * (L[s]{-1} * PROG_L[s]{-1} * CL[s]{-1}          / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 6) * d(log(PMAT[s]) - log(PE[s] + PE_Signal[s])) * (E[s]{-1} * (PE[s]{-1} + PE_Signal[s]{-1}) / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if MAT_n[s] <> 0
   
   
   
   @over d(SUBST_E_n[ce, s]) = sum( -ES_NRJ($s, cols_ce(ce, ce_oth)) * d(log(PE[ce, s] + PE_Signal[ce, s]) - log(PE[ce_oth, s] + PE_Signal[ce_oth, s])) * _
                              (PE[ce_oth, s]{-1} + PE_Signal[ce_oth, s]{-1})*E[ce_oth, s]{-1} / ((PE[s]{-1}+PE_Signal[s]{-1})*E[s]{-1}) if ce_oth <> ce on ce_oth in %list_com_E) _
                         if E[ce, s] <> 0
                         
   @over PE_signal[snets] * E[snets]  = sum(PE_signal[ce,snets] * E[ce,snets] on ce)   if E[snets] > 0
   
   @over PE_signal[sets] * E[sets]  = sum(PE_signal[ce,sets] * E[ce,sets] on ce) + PE_signal_ETS  * EMS_SEC[sets] * PCH    if E[sets] > 0
   
   @over PE_signal[22,sinc] = PE_signal_22_sinc 
                                             
   @over PE_signal[22,ster] = PE_signal_22_ster
   
   @over PE_signal[23,sinc] = PE_signal_23_sinc
   
   @over PE_signal[23,ster] = PE_signal_23_ster
   
   
   ##    Les constructions neuves diminuent en cas de transition énergétique : 
   ## le taux de destruction ne concerne que les classes e f et g. la rénovation énergétique diminue lassiette de la destruction du bâti.
   
   #@over Buil_DES = @elem(Buil_DES/Buil,%baseyear)*Buil{-1}
     
   ##-----------------------Calibration Labour productivity by sectors
    
   GR_PROG_L[s] = GR_PROG_L
   
  ##-------------------- Endogenous elasticity
   
dlog(PE_a[sne]) =  0.8*dlog(PE_a[sne]{-1}) + (1-0.8)*dlog(PE[sne]) + 0.01*(log(PE[sne]{-1})- log(PE_a[sne]{-1})) 
   
dlog(CK_a[sne]) = 0.8*dlog(CK_a[sne]{-1})+ (1-0.8)*dlog(CK[sne]) + 0.01*(log(CK[sne]{-1})- log(CK_a[sne]{-1})) 
  
 @over d(eta_K_E_des[sne]) = (@year>2006) * (alpha_eta_K_E_PE[sne] * d(dlog(PE_a[sne])-dlog(CK_a[sne])))*(d(dlog(PE_a[sne])-dlog(CK_a[sne]))>0)
   
 @over eta_K_E[sne] = 0.5*eta_K_E[sne]{-1} +(1-0.5)*(eta_K_E_des[sne]) +0.1*(eta_K_E_des[sne]{-1}-eta_K_E[sne]{-1})

#pour estimer alpha_eta_K_E_PE, il faut geler les 2 lignes ci-dessus. Activer les lignes ci-dessous. 
#  Il faut estimer lambda_eta_KE_PE en simulant un choc permanent des prix de l'énergie de 1% via les taux de taxe énergétique tenertD et tenertM.
# il faut ensuite reporter les valeurs obtenues des lambda_eta_KE_PE à moyen terme (10 ans) dans la matrice dédiée du fichier SAM_FRA_AME intitulée ES_eta_K_E
# Il faut également y reporter les valeur obtenues du TMS[sne].
#Il faut ensuite refaire tourner le modèle, et reporter les valeurs obtenues des alpha_eta_K_E_PE[sne] dans le même matrice.
#enfin, il faut réactiver les 2 lignes ci-dessus et geler les lignes ci dessous.
#gel 
#gel alpha_TMS_PE[sne] = @elem(-PE[sne]/PIA[sne],%baseyear)*(((1+PE_trend[sne])/(@elem(R,%baseyear)-PE_trend[sne]))^2)*1/(1+@elem(R,%baseyear))* _
  #gel (1-((1+PE_trend[sne])/(1+@elem(R,%baseyear)))^14*(15-15*(1+PE_trend[sne])/(1+@elem(R,%baseyear))+ (1+PE_trend[sne])/(1+@elem(R,%baseyear)))) 
#gel                                                                                 
   #gel alpha_eta_K_E_PE[sne] = (@year>2008)*((lambda_eta_KE_PE[sne]*(1-TMS[sne]{-1}*E[sne]{-2}/K[sne]{-2})-@elem(alpha_TMS_PE[sne],%baseyear)*E[sne]{-2}/K[sne]{-2}*(lambda_eta_KE_PE[sne]*PE_trend[sne]{-1}))/((CK_trend[sne]{-1}-PE_trend[sne]{-1})*(phi_cap[sne]{-1}*TMS[sne]{-1}*E[sne]{-2}/K[sne]{-2} +(1-phi_cap[sne]{-1}))+0.00001) _
 #gel + (TMS[sne]{-1}*E[sne]{-2}/K[sne]{-2}*phi_cap[sne]{-1}+(1-phi_cap[sne]{-1})-@elem(alpha_TMS_PE[sne],%baseyear)*E[sne]{-2}/K[sne]{-2}*phi_cap[sne]{-1}*(CK_trend[sne]{-1}-PE_trend[sne]{-1}))*(lambda_eta_KE_PE[sne]*PE_trend[sne]{-1})*(1-TMS[sne]{-1}*E[sne]{-2}/K[sne]{-2})/ _
   #gel ((CK_trend[sne]{-1}-PE_trend[sne]{-1})*(phi_cap[sne]{-1}*TMS[sne]{-1}*E[sne]{-2}/K[sne]{-2} +(1-phi_cap[sne]{-1}))+0.00001)^2) + (@year<=2008)*0
#gel 
#gel  
#gel PE_trend[sne] = (@year>2008)*((STEADYSTATE(2, 1) +0.01) + (@year<=2008) *STEADYSTATE(2, 1)  
#gel 
#gel TMS[sne]  = (TMS[sne]{-1} + @elem(alpha_TMS_PE[sne],%baseyear) * d(PE_trend[sne]))


##################################
######################################
###############################
# From Exception AME-AMS.mdl
##################################
#################################

# If need: Production price use actual stock of capital

#@over PY_n[s]*Y[s] = (CK[s]*K[s]+ CL[s]*L_n[s]*PROG_L[s] + PE[s]*E_n[s] + PMAT[s]*MAT_n[s]) * (1 + TMD[s]) if Y[s] > 0 where s in %list_sec

# If need: No adjustments for investments in the electricity sector

#@over IA[se23] = (K_n[se23] > (1 - Tdec[se23]) * K_n[se23]{-1}) * (K_n[se23] - (1 - Tdec[se23]) * K_n[se23]{-1}) + _
                # (K_n[se23] <= (1 - Tdec[se23]) * K_n[se23]{-1}) * 0.1

# Shorter names to overcome eViews' brilliant limitations...
q22 = q_mtep_ef_sou_22
q23 = q_mtep_ef_sou_23
q24 = q_mtep_ef_sou_24



# No electricity exports by 2050

@over X_23 = @elem(X_23, 2006) * (1 - 0.05) ^ (@year - 2006)

# Cross-consumption between energy sectors
# Q_Mtep_ener_in[ce, se]: intermediate energy consumed by sector se to produce energy commodity ce
# Q_Mtep_ener_out[ce, se]: intermediate energy ce produced by sector se to be consumed by other energy sectors

@over Q_Mtep_ef_tot[ce, se] = Q_Mtep_ef[ce, se]  + Q_Mtep_X[ce, se] + Q_Mtep_Nener[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ef_tot[ce, se] <> 0

# Take cross-consumptions into account for primary energy consumption

@over Q_Mtep_ep[ce, se] = Q_Mtep_ef[ce, se] + Q_Mtep_X[ce, se] + Q_Mtep_int[ce, se] + Q_Mtep_Losses[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ep[ce,se] <> 0

# Special case for methanation in 2303

#@over Q_Mtep_ef_tot[23, 2303] = Q_Mtep_ef[23, 2303]  + Q_Mtep_X[23, 2303] + Q_Mtep_indus[23, 2303]

# power to gaz

#Q_Mtep_in[24, 2303] = (1-AME)*(0 + (2030>@year>2025)*0.5*Q_Mtep_ep[2303] +(@year>2030)*0.9*Q_Mtep_ep[2303])

#Q_Mtep_out[23, 2402] = (1-AME)*(Q_Mtep_in[24, 2303])        

# méthanation

Q_Mtep_in[23, 2402] = (1-AME)*(0 +(@year>2040)*0.5*(1+0.15))

Q_Mtep_out[24, 2305] = (1-AME)*(Q_Mtep_ep[23, 2402])              

@over dlog(E[ce, se]) = dlog(E[se]) + d(SUBST_E[ce, se]) + (@year>2006)*d(Q_Mtep_in[ce, se])/E[ce, se]{-1}    if E[ce, se] <> 0


#CAPEX[se] = d(K[se])

CAPEX[se] = CK[se] * K[se] / P


# If need: Endogenous energy efficiency

#@over d(eta_L_E_des[sne]) = endo_L_E * (d(log(PE[sne]) - log(CL[sne])))*(d(log(PE[sne]) - log(CL[sne]))>0)

#@over d(eta_L_E_des[trsp]) = 0.7 * endo_L_E * (d(log(PE[trsp]) - log(CL[trsp])))*(d(log(PE[trsp]) - log(CL[trsp]))>0)

eta_L_E[sne] = 0.5 * eta_L_E_des[sne] + (1 - 0.5)*eta_L_E[sne]{-1}  + 0.02*(eta_L_E_des[sne]{-1} - eta_L_E[sne]{-1})                   


# Exogenous energy efficiency improvements in housing electricity consumption
# (e.g. appliances improvements stemming from R&D in the rest of the world)
# It is only applied at the very end of the trajectory
# Half of that ee is also applied to natural gas consumption

@over d(log(ENERperM2[ ecl, ce])) = -eta_BUIL[ce] * d(log(PEXP[ce] + PE_Signal_H[ce])-log(PCH))*(d(log(PEXP[ce] + PE_Signal_H[ce])-log(PCH))>0) + d(SUBST_BUIL[ ecl, ce]) + log(1 + exo_ee_appliances) if ENER_BUIL[ ecl, ce] <> 0 where ce in 22 23

@over d(log(ENERperM2[ ecl, 24])) = -eta_BUIL[24] * d(log(PEXP[24] + PE_Signal_H[24])-log(PCH))*(d(log(PEXP[24] + PE_Signal_H[24])-log(PCH))>0) + d(SUBST_BUIL[ ecl, 24]) if ENER_BUIL[ ecl, 24] <> 0

@over d(log(EXP_BUIL[ ecl, ce])) = (@year<=%baseyear)*log(1+STEADYSTATE(2,1)) + _  
                                    (@year>%baseyear)*(d(log(ENER_BUIL[ ecl, ce])) - d(log(PROG_BUIL[ ecl, ce]))) if ENER_BUIL[ ecl, ce] <> 0           

PROG_BUIL[ ecl, 21] = PROG_BUIL_21
              
PROG_BUIL[ ecl, 22] = PROG_BUIL_22
              
PROG_BUIL[ ecl, 23] = PROG_BUIL_23
              
PROG_BUIL[ ecl, 24] = PROG_BUIL_24              

# Distribution of energy taxes receipts
#--------------option 1

REDIS_VAL = (sum((TenertD[ce] - @elem(TenertD[ce],%baseyear))*(YQ[ce]+M[ce]) on ce))

REDIS_VAL_H = REDIS_VAL*Q_Mtep_H/Q_Mtep_ef

REDIS_VAL_SEC = REDIS_VAL - REDIS_VAL_H

@over DISPINC_VAL = DISPINC_AI_VAL - IR_VAL - AIC_VAL + REDIS_VAL_H + SUB_AUTO_VAL + SUB_REHAB_VAL       

@over DEP_VAL = CL_S[sp]*L_S[sp]*PROG_L[sp] + R_G{-1}*DEBT_G_VAL{-1} + PRESOC_VAL + SUB_REHAB_VAL + SUB_AUTO_VAL + REDIS_VAL_H _
                + value(E[sp] + MAT[sp] + IY[sp] + IA[sp] + (G - G[sp]) - ((SUB - SUB_01) + (SY - SY_01)))

@over TCSE[s] = @elem(TCSE[s], %baseyear) - (REDIS_VAL_SEC + DEP_TCO_VAL)/(W_S * L_S)

@over d(TIR) = -d(PHI_TCO * TCO_VAL_HH / DISPINC_AI_VAL) + d(TIR_TREND)

#----------------------option 2

#@over TCSE[s] = @elem(TCSE[s], %baseyear) - REC_TCO_VAL/(W_S * L_S)

#@over d(TIR) = 0 

#----------------------option 3    


@over PIS[s] * IS[s] = TIS * PRF[s]{-1} * RF[s]{-1} * (RF[s]{-1}>0) + 0.00000001 * (RF[s]{-1} =< 0) - (@year>2018)*TCO_VAL_SEC{-1}*PY[s]{-1}*Y[s]{-1}/(PY{-1}*Y{-1})  

@over DEP_VAL = CL_S[sp]*L_S[sp]*PROG_L[sp] + R_G{-1}*DEBT_G_VAL{-1} + PRESOC_VAL + SUB_REHAB_VAL + SUB_AUTO_VAL + REDIS_VAL_H _
                + value(E[sp] + MAT[sp] + IY[sp] + IA[sp] + (G - G[sp]) - ((SUB - SUB_01) + (SY - SY_01))) + (@year>2018)*TCO_VAL_SEC{-1}

@over TCSE[s] = @elem(TCSE[s], %baseyear) 

#----------------------option 4    recession divisée par 3 mais bug si TCO trop élevée


#@over PIS[s] * IS[s] = TIS * PRF[s]{-1} * RF[s]{-1} * (RF[s]{-1}>0) + 0.00000001 * (RF[s]{-1} =< 0) - (@year>2018)*REC_TCO_VAL{-1}*PY[s]{-1}*Y[s]{-1}/(PY{-1}*Y{-1})  
#
#@over DEP_VAL = CL_S[sp]*L_S[sp]*PROG_L[sp] + R_G{-1}*DEBT_G_VAL{-1} + PRESOC_VAL + SUB_REHAB_VAL + SUB_AUTO_VAL + REDIS_VAL_H _
                #+ value(E[sp] + MAT[sp] + IY[sp] + IA[sp] + (G - G[sp]) - ((SUB - SUB_01) + (SY - SY_01))) + (@year>2018)*REC_TCO_VAL{-1}
#
#@over TCSE[s] = @elem(TCSE[s], %baseyear) 
#
#@over d(TIR) = 0

# -------------------------------------Evolution des prix à l'import sous l'effet de la lutte généralisée contre le rechauffement climatique

#@over PWD[sne] = (@year<=2018)*PWD_n[sne] + (@year>2018)*PWD_n[sne]*(1+TCO_VAL_SEC[sne]{-1}/CU[sne]{-1}*TTCO_VOL_ROW/TTCO_VOL_21) #where c in %list_com \ %list_com_E  # la chronique est fournie par la DGEC

#PWD[sne] = (@year<=2018)*PWD_n[sne] + (@year>2018)*PWD_n[sne]*(1+DELTA_TTCO_ROW*TCO_VAL_SEC[sne]{-1}/(CU[sne]{-1}*Y[sne]{-1} ))

# ------------------------politique monétaire
            
# attention, ne pas redistribuer la totalité des intérêts sinon, politique monétaire procyclique

@over d(R_DIR) = 1* d(infl_FR) + d(R_ADD) #- 0.8 * d(Unr_tot) 
 
@over d(R_S)= 0.3*d(R)
      
# Subvention pour les logements (CIDD)

SUB_REHAB_VAL[ ecl] = sum(R_SUB[ecl,ecl2] * PREHAB[ecl,ecl2] * REHAB[ecl,ecl2] if REHAB[ecl,ecl2]  <> 0 on ecl2)

SUB_REHAB_VAL = sum(SUB_REHAB_VAL[ ecl] on ecl)

 
EXP_ENER = sum(EXP[ce] on ce)

PEXP_ENER*EXP_ENER = sum(PEXP[ce]*EXP[ce] on ce)        # il faut écrire PEXP[ce]     # corrigé


# sobriété, reglementation thermique, substitution interénergie dans logement

@over d(log(ENERperM2[ ecl, ce])) = -eta_BUIL* d(log(PEXP[ce])-log(PCH))*(d(log(PEXP[ce])-log(PCH))>0) + d(SUBST_BUIL[ ecl, ce]) if ENER_BUIL[ ecl, ce] <> 0

d(SUBST_BUIL[ ecl, ce]) = (@year>%baseyear)*(sum(-ES_BUILNRJ($ecl, cols_ce(ce, ce_oth)) * d(log(PEXP[ce]) - log(PEXP[ce_oth])) * _
                           (PEXP[ce_oth]{-1}*EXP_BUIL[ ecl, ce_oth]{-1}) /(PEXP_BUIL[ ecl]{-1}*EXP_BUIL[ ecl]{-1}) if ce_oth <> ce on ce_oth in %list_com_E))_
                            if  PEXP[ce]*EXP_BUIL[ ecl, ce] <> 0

# export of energy commodities

@over X[ce] = @elem(X[ce],%baseyear)


#energy price signal

ENER_price_signal = (sum(value(ENERT[ce] + OTHT[ce] + SUB[ce]) on ce)+ Rec_TCO_VAL )/ (Q_Mtep_ef * PGDP)

ENER_price_signal[ce] = (value(ENERT[ce] + OTHT[ce] + SUB[ce]) + TCO_VAL_SOU[ce] + TCO_VAL_HH_SOU[ce]) / (Q_Mtep_ef_SOU[ce] * PGDP)

#implicite Carbon tax

Ttco_signal[21] = 1000000 * (value(ENERT[21]+ OTHT[21] + SUB[21]) + TCO_VAL_SOU[21] + TCO_VAL_HH_SOU[21])/ (EMS_SECSOU[21] + EMS_HH[21])

Ttco_signal[22] = 1000000 * ((value(ENERT[22]+ OTHT[22] + SUB[22])) * PHIY_ef_tot[22,2201] + TCO_VAL_SOU[22] + TCO_VAL_HH_SOU[22])/ (EMS_SECSOU[22] + EMS_HH[22])

#Ttco_signal[23] = 1000000 * ((value(ENERT[23]+ OTHT[23] + SUB[23])) * (PHIY_ef_tot[23,2302] + PHIY_ef_tot[23,2303] + PHIY_ef_tot[23,2304]) + TCO_VAL_SOU[23] + TCO_VAL_HH_SOU[23])/ (EMS_SECSOU[23] + EMS_HH[23])

Ttco_signal[24] = 1000000 * ((value(ENERT[24]+ OTHT[24] + SUB[24])) * PHIY_ef_tot[24,2401] + TCO_VAL_SOU[24] + TCO_VAL_HH_SOU[24])/ (EMS_SECSOU[24] + EMS_HH[24])

Ttco_vol_signal[ce2] = Ttco_signal[ce2]/PGDP

Ttco_signal = ((sum(Ttco_signal[ce2] * (EMS_SECSOU[ce2] + EMS_HH[ce2]) on ce2)) )/ (EMS_SEC + EMS_HH)

Ttco_vol_signal = Ttco_signal/PGDP

#production unit cost of energy sectors per MTEP

CU_MTEP[se] = ((CU[se]*Y[se])/Q_mtep_ef[se]) / P #(CU[se]*Y[se])/(PY[se]*Q_mtep_ef[se])

CU_MTEP_PGDP[se] =  (CU[se]*Y[se])/(PGDP*Q_mtep_ef_tot[se])      # modifié Gaël

CU_MTEP_22 = (sum(CU[se22]*Y[se22]/PY[se22] on se22))/Q_mtep_ef_tot_sou_22    # modifié Gaël

CU_MTEP_23 = (sum(CU[se23]*Y[se23]/PY[se23] on se23))/Q_mtep_ef_tot_sou_23     # modifié Gaël

CU_MTEP_24 = (sum(CU[se24]*Y[se24]/PY[se24] on se24))/Q_mtep_ef_tot_sou_24     # modifié Gaël

CU_MTEP_PGDP_22 = (sum(CU[se22]*Y[se22]/PGDP on se22))/Q_mtep_ef_tot_sou_22    # modifié Gaël

CU_MTEP_PGDP_23 = (sum(CU[se23]*Y[se23]/PGDP on se23))/Q_mtep_ef_tot_sou_23   # modifié Gaël

CU_MTEP_PGDP_24 = (sum(CU[se24]*Y[se24]/PGDP on se24))/Q_mtep_ef_tot_sou_24    # modifié Gaël

# production unit cost of energy sectors per Mwh

CU_MWH[se] = CU_MTEP[se]*0.086

CU_MWH_PGDP[se] = CU_MTEP_PGDP[se]*0.086

CU_MWH_22 = CU_MTEP_22*0.086

CU_MWH_23 = CU_MTEP_23*0.086

CU_MWH_24 = CU_MTEP_24*0.086

CU_MWH_PGDP_22 = CU_MTEP_PGDP_22*0.086

CU_MWH_PGDP_23 = CU_MTEP_PGDP_23*0.086

CU_MWH_PGDP_24 = CU_MTEP_PGDP_24*0.086

# energy bill in % of GDP

EGDP_bill[ce] = CH[ce]/GDP

EGDP_bill = (sum(CH[ce] on ce))/GDP

#industrial production in % of GDP

YQGDP_ind = (sum(YQ[sind] on sind))/GDP

#TTCO[ce2] =TTCO[ce2]{-1}*(1+GR_TCO)

# GDP growth rate

GR_GDP = dlog(GDP)

 #------------ dans AME l'enveloppe correspondant aux montant des dépenses fiscales du bonus automobile est sensée restée constante. 

bonus_elec= AME*((@year>2018)*((350*(1+STEADYSTATE(15,1))^(@year - 2018))/NEWAUTO_elec) + (@year<=2018)*(R_bonus_elec)) + (1-AME)*R_bonus_elec

@over bonus_th[ecl]= AME * R_bonus_th[ecl] +   (@year<=2018)*(1-AME)*R_bonus_th[ecl] + (@year>2018)*(1-AME)*(bonus_th[ecl]{-1} - (@year<2040)*d(bonus_elec*NewAuto_elec)/NewAuto_th ) 

#@over bonus_th[ecl]= AME * R_bonus_th[ecl] +   (@year<=2018)*(1-AME)*R_bonus_th[ecl] + (@year>2018)*(1-AME)*(bonus_th[ecl]{-1}*(1 - (@year<2040)*d(bonus_elec*NewAuto_elec)/(sum(bonus_th[ecl]{-1}*Newauto_th[ecl]{-1} on ecl))))

#@over d(log(E_oth[24, 15])) = d(log(E_oth[15])) + d(SUBST_E[24, 15]) + dlog(GR_E[24, 15]) if E_oth[24, 15] <> 0   


#----------------------- Energy Reporting

ER_Trans_Private = Q_Mtep_H_AUTO
ER_Trans_Public = sum(Q_Mtep_sec[trsp] on trsp)
ER_Residential = Q_Mtep_H_BUIL
ER_Tertiary = Q_Mtep_sec[19] + Q_Mtep_sec[20]
ER_Indus = sum(Q_Mtep_sec[sind] on sind)
ER_Agriculture = Q_Mtep_sec_01

ER_Trans_Private_coal = Q_Mtep_H_AUTO_21
ER_Trans_Public_coal = sum(Q_Mtep_sec_21[trsp] on trsp)
ER_Residential_coal = Q_Mtep_H_BUIL_21
ER_Tertiary_coal = Q_Mtep_sec_21[19] + Q_Mtep_sec_21[20]
ER_Indus_coal = sum(Q_Mtep_sec_21[sind] on sind)
ER_Agriculture_coal = Q_Mtep_sec_21_01

ER_Trans_Private_oil = Q_Mtep_H_AUTO_22
ER_Trans_Public_oil = sum(Q_Mtep_sec_22[trsp] on trsp)
ER_Residential_oil = Q_Mtep_H_BUIL_22
ER_Tertiary_oil = Q_Mtep_sec_22[19] + Q_Mtep_sec_22[20]
ER_Indus_oil = sum(Q_Mtep_sec_22[sind] on sind)
ER_Agriculture_oil = Q_Mtep_sec_22_01

ER_Trans_Private_elec = Q_Mtep_H_AUTO_23
ER_Trans_Public_elec = sum(Q_Mtep_sec_23[trsp] on trsp)
ER_Residential_elec = Q_Mtep_H_BUIL_23
ER_Tertiary_elec = Q_Mtep_sec_23[19] + Q_Mtep_sec_23[20]
ER_Indus_elec = sum(Q_Mtep_sec_23[sind] on sind)
ER_Agriculture_elec = Q_Mtep_sec_23_01

ER_Trans_Private_gas = Q_Mtep_H_AUTO_24
ER_Trans_Public_gas = sum(Q_Mtep_sec_24[trsp] on trsp)
ER_Residential_gas = Q_Mtep_H_BUIL_24
ER_Tertiary_gas = Q_Mtep_sec_24[19] + Q_Mtep_sec_24[20]
ER_Indus_gas = sum(Q_Mtep_sec_24[sind] on sind)
ER_Agriculture_gas = Q_Mtep_sec_24_01

ER_oil = sum(Q_Mtep_ef[se22] on se22)
ER_oil_2201 = Q_mtep_ef_2201
ER_oil_2202 = Q_mtep_ef_2202
ER_elec = sum(Q_Mtep_ef[se23] on se23)
ER_elec_2301 = Q_MTEP_ef_2301 
ER_elec_2302 = Q_MTEP_ef_2302 
ER_elec_2303 = Q_MTEP_ef_2303 
ER_elec_2304 = Q_MTEP_ef_2304 
ER_elec_2305 = Q_MTEP_ef_2305 
ER_elec_2306 = Q_MTEP_ef_2306 
ER_elec_2307 = Q_MTEP_ef_2307 
ER_elec_2308 = Q_MTEP_ef_2308 
ER_gas = sum(Q_Mtep_ef[se24] on se24)
ER_gas_2401 = Q_MTEP_ef_2401  
ER_gas_2402 = Q_MTEP_ef_2402  
ER_gas_2403 = Q_MTEP_ef_2403  
ER_gas_2404 = Q_MTEP_ef_2404  
ER_gas_2405 = Q_MTEP_ef_2405
ER_gas_2406 = Q_MTEP_ef_2406  
ER_Coal = Q_mtep_ef_21

ER_ep_oil = sum(Q_Mtep_ep[se22] on se22)
ER_ep_oil_2201 = Q_mtep_ep_2201
ER_ep_oil_2202 = Q_mtep_ep_2202
ER_ep_elec = sum(Q_Mtep_ep[se23] on se23)
ER_ep_elec_2301 = Q_MTEP_ep_2301  
ER_ep_elec_2302 = Q_MTEP_ep_2302  
ER_ep_elec_2303 = Q_MTEP_ep_2303  
ER_ep_elec_2304 = Q_MTEP_ep_2304  
ER_ep_elec_2305 = Q_MTEP_ep_2305  
ER_ep_elec_2306 = Q_MTEP_ep_2306  
ER_ep_elec_2307 = Q_MTEP_ep_2307  
ER_ep_elec_2308 = Q_MTEP_ep_2308  
ER_ep_gas = sum(Q_Mtep_ep[se24] on se24)
ER_ep_gas_2401 = Q_MTEP_ep_2401 
ER_ep_gas_2402  = Q_MTEP_ep_2402  
ER_ep_gas_2403  = Q_MTEP_ep_2403  
ER_ep_gas_2404  = Q_MTEP_ep_2404  
ER_ep_gas_2405  = Q_MTEP_ep_2405
ER_ep_gas_2406  = Q_MTEP_ep_2406  
ER_ep_Coal = Q_mtep_ep_21

ER_Total = Q_Mtep_ef
ER_ep_Total = Q_Mtep_ep

ER_Auto = AUTO

ER_AUTO_Coal = AUTO_21
ER_Auto_th = AUTO_th
ER_Auto_Elec = AUTO_elec
ER_Auto_gas = AUTO_24

ER_AUTO_th_A = AUTO_th_CA
ER_AUTO_th_B = AUTO_th_CB
ER_AUTO_th_C = AUTO_th_CC
ER_AUTO_th_D = AUTO_th_CD
ER_AUTO_th_E = AUTO_th_CE
ER_AUTO_th_F = AUTO_th_CF
ER_AUTO_th_G = AUTO_th_CG

ER_AUTO_elec_A = AUTO_elec_CA
ER_AUTO_elec_B = AUTO_elec_CB
ER_AUTO_elec_C = AUTO_elec_CC
ER_AUTO_elec_D = AUTO_elec_CD
ER_AUTO_elec_E = AUTO_elec_CE
ER_AUTO_elec_F = AUTO_elec_CF
ER_AUTO_elec_G = AUTO_elec_CG

ER_NEWAUTO = newauto_th + newauto_elec

ER_NEWAUTO_th = newauto_th
ER_NEWAUTO_th_A = newauto_th_ca
ER_NEWAUTO_th_b = newauto_th_cb
ER_NEWAUTO_th_c = newauto_th_cc
ER_NEWAUTO_th_d = newauto_th_cd
ER_NEWAUTO_th_e = newauto_th_ce
ER_NEWAUTO_th_f = newauto_th_cf
ER_NEWAUTO_th_g = newauto_th_cg

ER_NEWAUTO_elec = newauto_elec
ER_NEWAUTO_elec_A = newauto_elec_ca
ER_NEWAUTO_elec_b = newauto_elec_cb
ER_NEWAUTO_elec_c = newauto_elec_cc
ER_NEWAUTO_elec_d = newauto_elec_cd
ER_NEWAUTO_elec_e = newauto_elec_ce
ER_NEWAUTO_elec_f = newauto_elec_cf
ER_NEWAUTO_elec_g = newauto_elec_cg


ER_BUIL = BUIL

ER_BUIL_A = BUIL_CA     
ER_BUIL_B = BUIL_CB     
ER_BUIL_C = BUIL_CC     
ER_BUIL_D = BUIL_CD     
ER_BUIL_E = BUIL_CE     
ER_BUIL_F = BUIL_CF     
ER_BUIL_G = BUIL_CG     
    

ER_Inv_Wind = CAPEX_2305
ER_Inv_Solar = CAPEX_2306
ER_Jobs_Public_Trsp = sum(L[trsp] on trsp)




