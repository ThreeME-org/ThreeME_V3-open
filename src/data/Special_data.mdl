include ..\model\lists

### This file defines the variables that are not loaded and that can not be calculated from their equation in the model. There may be several reasons: 
### - they are defined by a behavor equation.
### - using the equation of the model generate a circular reference

### Export of commodity c be used in the corresponding behavor equation
Xbis[c] := X[c]

### Calibration of parameter from Equations
PhiY[c, s] := Y[c, s]/YQ[c]
W[s] := WAGES[s] * PWAGES[s] / F[L, s]
(1 + MARKUP[s]) := PY_n[s] / CU_n[s]

RNTAXPD[c] := NTAXPD[c]/YQ[c]
RNTAXPM[c] := NTAXPM[c]/ M[c]


RINC_SOC_TAX := INC_SOC_TAX_VAL / DISPINC_BT_VAL
phi_PROP_INC := PROP_INC_VAL_n / (PNOS * NOS) 

(1 - MPS_n) := CH_n_VAL / DISPINC_AT_VAL 

phi_MCH[c] := (CH_n[c] - NCH[c]) * PCH[c] / (CH_n_VAL - PNCH * NCH)

PARTR := LF/WAPop

# Tax rate for the Employers' social security contribution paid by sector s
(1 + RRSSC[s]) := RSSC[s] * PRSSC[s] / (W[s] * F[L, s])

# Import share of commodity c for margins recieved, private and public consumption, investment and exports 
phi_|V|M[c] := |V|M[c]/|V|[c] where V in MGR CH G X

# Import share of commodity c bought by sector s for intermediary consumption and investment
phi_|V|M[c, s] := |V|M[c, s]/|V|[c, s] where V in CI I

# From equilibrated steady state
Stock_SAVH := SAVH * (1 + GR_NOMI) / GR_NOMI


# Alias or defined to be used in behavor equations
IA[s] := I[s]

F[E, s] := sum(CI[ce, s] on ce)
F[MAT, s] := sum(CI[cm, s] on cm)

TRSP[s] := sum(CI[ct, s] on ct)

F_n[K, s] := F[K, s]
F_n[L, s] := F[L, s]
F_n[E, s] := F[E, s]
F_n[MAT, s] := F[MAT, s]

F_e[f, s] := F[f, s]

CI[c, s] := CID[c, s] + CIM[c, s]
I[c, s] := ID[c, s] + IM[c, s]
|V|[c] := |V|D[c] + |V|M[c] where V in CH G X

CH_n_VAL := PCH * CH

EXPG := G 

# For verif
ES_|V|M_act[c] := ES_|V|M[c] where V in MGR CH G X

# Expected and nominal variables are initialised to their real value
|V|_n[s] := |V|[s] where V in IA W MARKUP
|V|_e[s] := |V|[s] where V in IA W

|V|_n[c] := |V|[c] where V in CH
|V|_e[c] := |V|[c] where V in CH



Y_e[s] := Y[s]

|V|_n := |V| where V in PARTR R PROP_INC_VAL

PROP_INC_VAL_e := PROP_INC_VAL

### Voir si on ne peux pas regrouper un peu !!!
R_e := R

PARTR_trend := PARTR
PARTR_e := PARTR

DNAIRU := 0

# All variable started by SUBST are calibrated to zero
SUBST_MGPD[cc, c] := 0
SUBST_MGPM[cc, c] := 0

SUBST_n_MGPD[cc, c] := 0
SUBST_n_MGPM[cc, c] := 0

SUBST_|V|[s] := 0 where V in IA L E MAT K

SUBST_n_F[f, s] := 0
SUBST_F[f, s] := 0

SUBST_n_CI[c, s] := 0
SUBST_CI[c, s] := 0

SUBST_n_|V|M[c] := 0 where V in MGR CH G X
SUBST_|V|M[c] := 0 where V in MGR CH G X

SUBST_n_|V|M[c, s] := 0 where V in CI I
SUBST_|V|M[c, s] := 0 where V in CI I

SUBST_n_X[c] := 0
SUBST_X[c] := 0

#SUBST_|V|_n[c, s] := 0 where V in IA IAD IAM
#SUBST_|V|[c, s] := 0 where V in IA IAD IAM
#SUBST_|V|_n[ce, s] := 0 where V in E  ED EM
#SUBST_|V|[ce, s] := 0 where V in E  ED EM
#SUBST_|V|_n[cm, s] := 0 where V in MAT MATD MATM
#SUBST_|V|[cm, s] := 0 where V in MAT MATD MATM

#SUBST_|V|_n[c] := 0 where V in CHD CHM GD GM X XD XM
#SUBST_|V|[c] := 0 where V in CHD CHM GD GM X XD XM
#SUBST_|V|_n[trsp, c] := 0 where V in MTD MTM, c in %list_com \ %list_trsp
#SUBST_|V|[trsp, c] := 0 where V in MTD MTM, c in %list_com \ %list_trsp




## Verification variable: ok if equal to 0
### Pour le compilateur: avoir un nom réservé pour Verif?

verif_phi_F[s] := 0

verif_phi_MGPD[c] := 0

verif_phi_MGPM[c] := 0

verif_phi[E, s] := 0

verif_phi_TRSP[s] := 0

Verif_PCH_CES := 0 

Verif_phi_CH := 0 

Verif_phi_MCH := 0 

Verif_ALL := 0 

Verif_ALL_ES := 0 

Verif_ES_|V|M[c] := 0  where V in MGR CH G X


#VERIF_|V| := 0 where V in PY_PYQ Y_YQ PIAxIA_PIxI PIA_PI IA_I GDP_GDPBIS GDP_GDPTER PGDP_PGDPBIS PGDP_PGDPTER ValGDP_ValGDPTER
#VERIF_PEXP_CES[h] := 0




## Other Calibrations
### Calibrated from the volume version of an equation in value. Volume not in the model because of cirlar reference. 
### We can not use the Eq of the model:  YQ[c]*PYQ[c] + NTAXPD_VAL[c] + PMGPD[c]*MGPD[c] := PQD[c]*QD[c]
### because circular reference with NTAXPD_VAL[c] that depends on YQ[c].
### 
YQ[c] := sum(Y[c, s] on s)


### Idem for M[c]. M[c]*PM[c] + NTAXPM_VAL[c] + PMGPM[c]*MGPM[c] := PQM[c]*QM[c]
### because circular reference with NTAXPM_VAL[c] that depends on M[c]. Use round 0 instead:

M[c] := SUT($c,7) * (1 + GR_REAL) ^ (@year - %baseyear)

# As explained, these can not be the eq of the model (otherwise incorrect price)
YQS[c] := YQ[c] + NTAXPD[c] + MGPD[c]
MS[c] := M[c] + NTAXPM[c] + MGPM[c] 






