include ..\model\lists

  
  

# Subventions automobile ( Bonus-malus auto + bonus elec)

SUB_AUTO_VAL[ ecl] = R_SUB_AUTO[ ecl]*PNewAUTO[ ecl] * NewAUTO[ ecl]

SUB_AUTO_VAL = sum(SUB_AUTO_VAL[ecl] on ecl)






#####Définition du coût de maintenance (hors batterie) du véhicule électrique:


UC_auto_elec = sum(@elem(phi_elec[pcl],%baseyear)* (UC_K_auto_elec[pcl] + UC_E_auto_elec[pcl]) on pcl) + UC_M_auto_elec 


UC_auto_th = sum(@elem(phi_NewAUTO[ecl,th],%baseyear)* (UC_K_AUTO[ecl,th] + UC_E_AUTO[ecl,th]) on ecl) + UC_M_auto_th
 


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


 # Modal shift in transportation
 ## modal_shift_freight * (1 + 1/4)????
 ### NE PAS INCLURE DANS V3
@over d(log(MAT[16, s])) = d(log(MAT[s])) + d(SUBST_MAT[16, s]) + log(1 -  modal_shift_freight * (1 + 1/4) * MAT[16, s]{-1} / MAT[16, s]{-1}) if MAT[16, s] <> 0

@over d(log(MAT[14, s])) = d(log(MAT[s])) + d(SUBST_MAT[14, s]) + log(1 +  modal_shift_freight             * MAT[16, s]{-1} / MAT[14, s]{-1}) if MAT[14, s] <> 0

@over d(log(MAT[17, s])) = d(log(MAT[s])) + d(SUBST_MAT[17, s]) + log(1 + (modal_shift_freight / 4)        * MAT[16, s]{-1} / MAT[17, s]{-1}) if MAT[17, s] <> 0
 


    
    # Exception for the households block
    
  
  # -----------------------------------------------Households expenditures --------------------------------
  # equation H.4.139
  
  @over d(log(NEXP[co])) = (@year >  %baseyear) * d(log(Pop_TOT)) + (@year <=  %baseyear) * log( 1 + GR_REAL)  where co in 01
  



## ------------------------ implicit price signal insertion  
### Should noe use the new more general specification!!!
## Should PE_Signal[s] really appeat in the denominator of the share
  @over d(SUBST_E_n[s]) = _
     -eta_K_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CK[s]))   * (K[s]{-1}   * CK[s]{-1}                 / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -eta_L_E[s]     * d(log((PE[s] + PE_Signal[s])) - log(CL[s]))   * (L[s]{-1}   * PROG_L[s]{-1} * CL[s]{-1} / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
     -ES_KLEM($s, 6) * d(log((PE[s] + PE_Signal[s])) - log(PMAT[s])) * (MAT[s]{-1} * PMAT[s]{-1}               / (CU[s]{-1} * Y[s]{-1}+ E[s]{-1} * PE_Signal[s]{-1})) _
   if E_n[s] <> 0
   
   
   @over d(SUBST_E_n[ce, s]) = sum( -ES_NRJ($s, cols_ce(ce, ce_oth)) * d(log(PE[ce, s] + PE_Signal[ce, s]) - log(PE[ce_oth, s] + PE_Signal[ce_oth, s])) * _
                              (PE[ce_oth, s]{-1} + PE_Signal[ce_oth, s]{-1})*E[ce_oth, s]{-1} / ((PE[s]{-1}+PE_Signal[s]{-1})*E[s]{-1}) if ce_oth <> ce on ce_oth in %list_com_E) _
                         if E[ce, s] <> 0
     
   
  ##-------------------- Endogenous elasticity
   
dlog(PE_a[sne]) =  0.8*dlog(PE_a[sne]{-1}) + (1-0.8)*dlog(PE[sne]) + 0.01*(log(PE[sne]{-1})- log(PE_a[sne]{-1})) 
   
dlog(CK_a[sne]) = 0.8*dlog(CK_a[sne]{-1})+ (1-0.8)*dlog(CK[sne]) + 0.01*(log(CK[sne]{-1})- log(CK_a[sne]{-1})) 
  
 @over d(eta_K_E_des[sne]) = (@year>2006) * (alpha_eta_K_E_PE[sne] * d(dlog(PE_a[sne])-dlog(CK_a[sne])))*(d(dlog(PE_a[sne])-dlog(CK_a[sne]))>0)
   
 @over eta_K_E[sne] = 0.5*eta_K_E[sne]{-1} +(1-0.5)*(eta_K_E_des[sne]) +0.1*(eta_K_E_des[sne]{-1}-eta_K_E[sne]{-1})



# sobriété, reglementation thermique, substitution interénergie dans logement

@over d(log(ENERperM2[ ecl, ce])) = -eta_BUIL* d(log(PEXP[ce])-log(PCH))*(d(log(PEXP[ce])-log(PCH))>0) + d(SUBST_BUIL[ ecl, ce]) if ENER_BUIL[ ecl, ce] <> 0

d(SUBST_BUIL[ ecl, ce]) = (@year>%baseyear)*(sum(-ES_BUILNRJ($ecl, cols_ce(ce, ce_oth)) * d(log(PEXP[ce]) - log(PEXP[ce_oth])) * _
                           (PEXP[ce_oth]{-1}*EXP_BUIL[ ecl, ce_oth]{-1}) /(PEXP_BUIL[ ecl]{-1}*EXP_BUIL[ ecl]{-1}) if ce_oth <> ce on ce_oth in %list_com_E))_
                            if  PEXP[ce]*EXP_BUIL[ ecl, ce] <> 0




   
##################################################################################################################################
############################ EMISSION ############################################################################################
##################################################################################################################################   
   
NE PAS REPRENDRE !!!! RELIER DIRECTEMENT AUX VOLUME COMPTAT NAT / Q_Mtep SONT SEULLEMENT DES SORTIES
POUR MEMOIRE. VOIR COMMMENT SIMPLIFIER 

    # Exception regarding MTEP/CO2EMS
    
    # Carbon intentity endogenous
    
    IC[22,s] = PhiY_ener[22, 2201]    #modifié Gaël
    
    IC[24,s] = PhiY_ener[24, 2401]    #modifié Gaël
    
    IC_HH[22] = PhiY_ener[22, 2201]  #modifié Gaël
                                      
    IC_HH[24] = PhiY_ener[24, 2401]    #modifié Gaël
    
    # Emission linked to internal uses of the branche
    
    @over d(log(EMS_SEC[22,2201])) = (@year>%baseyear)*d(log(Q_Mtep_int[22,2201])) + (@year=<%baseyear)*log(1 + GR_REAL)
    
    # household's emissions per source
    
    @over  d(log(EMS_HH[ce2])) = (@year>%baseyear)*dlog((Q_Mtep_H_Buil[ce2]+Q_Mtep_H_AUTO[ce2])*IC_HH[ce2]) + (@year=<%baseyear)*log(1 + GR_REAL) if EMS_HH[ce2] <> 0     #modifié Gaël
    
    # sector's emissions for energy and non energy uses
    
    dlog(EMS_SEC_indus[ce2,s]) = dlog(Q_Mtep_indus[ce2,s])  if EMS_SEC_indus[ce2,s]<>0   # modifié Gaël
      
    # for energy and non energy uses
    
      EMS_SEC_tot[ce2,s] = EMS_SEC[ce2,s] + EMS_SEC_indus[ce2,s]     # modifié Gaël
        
      EMS_SEC_tot[s] = sum(EMS_sec_tot[ce2,s] on ce2)                   # modifié Gaël
      
      EMS_SEC_tot = sum(EMS_sec_tot[s] on s)                            # modifié Gaël
    
    
    ### We should also include the following equation. But this would require reformulating the calculation of the
    ### different PhiY. We neglet this since EMS_SEC[24,2201] represent only 0.7% of the emission of sector 2201
    ### we therefore keep the orginal formulation: d(log(EMS_SEC[ce2,s])) = d(log(E[ce2,s]*IC[ce2,s]))
    ### @over d(log(EMS_SEC[24,2201])) = d(log(Q_Mtep_int[24,2201]))
    
    @over d(log(EMS_SEC[24,2401])) = (@year>%baseyear)*d(log(Q_Mtep_int[2401])) + (@year=<%baseyear)*log(1 + GR_REAL)
    
##################################################################################################################################
##################################################################################################################################
##################################################################################################################################


    # Share of energy commodities produced by energy sectors (national account definition)
    
    PhiY[ce, se] = PhiY_ef_tot[ce, se] * (1 - (sum(PhiY[ce, sne] if PhiY[ce, sne] <> 0 on sne))) if PhiY[ce, se] <> 0
    
    verif_PhiY[ce] = sum(PhiY[ce, s] if PhiY[ce, s] <> 0 on s) - 1
    
    # Share of final energy production (including fuel for industrial use)
    
    PhiY_ef_tot[ce, se] = Q_Mtep_ef_tot[ce,se]/Q_Mtep_ef_tot_SOU[ce] if PhiY_ef_tot[ce, se] <> 0
    
    Q_Mtep_ef_tot_SOU[ce] = sum(Q_Mtep_ef_tot[ce,se] on se)
    
    # Final energy share of energy commodities produced by energy sectors
    
    verif_PhiY_ef_tot[ce] = sum(PhiY_ef_tot[ce, se] if PhiY_ef_tot[ce, se] <> 0 on se) - 1
    
    # ***ENERGY PRODUCTION IN MTEP***
    
    # Final energy demand (excluding fuel for industrial use)
    
    Q_Mtep_ef[ce,se] = Q_Mtep_ef_SOU[ce] * PhiY_ener[ce, se] if PhiY_ener[ce, se] <> 0
    
    #-----------------------------Energy consumption in Mtep by use -----------------------------
    
    # Energy demand of Household by use
    
    d(log(Q_Mtep_H_BUIL[ce])) = (@year>%baseyear)*d(log(EXP_BUIL[ce])) + (@year=<%baseyear)*log(1 + GR_REAL) if EXP_BUIL[ce] <> 0 
    
    d(log(Q_Mtep_H_AUTO[ce])) = (@year>%baseyear)*d(log(EXP_AUTO[ce])) + (@year=<%baseyear)*log(1 + GR_REAL) if EXP_AUTO[ce] <> 0
    
    # Energy demand of sectors    
                                               
    d(log(Q_Mtep_SEC[ce, sne])) = (@year>%baseyear)*d(log(E_oth[ce, sne])) + (@year=<%baseyear)*log(1 + GR_REAL) if Q_Mtep_SEC[ce, sne] <> 0
    
    #---------------------------------------------------------------------------------------------
    
    
    Q_Mtep_X[ce,se]  = Q_Mtep_X_SOU[ce]  * PhiY_ener[ce, se] if Q_Mtep_X[ce,se] <> 0
    
    Q_Mtep_ef_SOU[ce] = Q_Mtep_H_BUIL[ce] + Q_Mtep_H_AUTO[ce] + Q_Mtep_SEC_SOU[ce]
    
    d(log(Q_Mtep_X_SOU[ce])) = d(log(X[ce])) if Q_Mtep_X_SOU[ce] <> 0
    
    # Energy production for non-energy/indus use
    ### For sector 8 (petrochemistry):  plastic made with petrol and fertilizer made with natural  gas;
    ### For sector 10 (steal): coal to make steal
    ### The reason for showing these is that most policy to reduce CO2 emmissions do not target emission from
    ### fuel for on-energy use.
    
    d(log(Q_Mtep_indus[ce,sne])) = d(log(E_indus[ce,sne])) if Q_Mtep_indus[ce,sne] <> 0
    
    # Energy internal uses and losses of the energy producers
    
    Q_Mtep_int[ce,se] = coef_int[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_int[ce,se] <> 0    # modifié
    
    Q_Mtep_Losses[ce,se] = coef_Losses[ce,se]*(Q_Mtep_ef[ce,se]+Q_Mtep_X[ce,se]) if Q_Mtep_Losses[ce,se] <> 0     # modifié
    
    
    # Energy Production in total final energy (including "energy"/fuel for non-energy/indus use)
    
    Q_Mtep_ef_tot[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_Nener[ce,se] if  Q_Mtep_ef_tot[ce,se] <> 0
    
    Q_Mtep_Nener[ce,se] =  Q_Mtep_indus[ce]*PhiY_indus[ce,se]
    
    Q_Mtep_Nener[ce] =  Q_Mtep_indus[ce]
    
    # Energy Production in primary energy (for energy use)
    
    Q_Mtep_ep[ce,se] = Q_Mtep_ef[ce,se] + Q_Mtep_X[ce,se] + Q_Mtep_int[ce,se] + Q_Mtep_Losses[ce,se] if Q_Mtep_ep[ce,se] <> 0
    
    # Agregations of Q_Mtep
    
    Q_Mtep_|V|[se] = sum(Q_Mtep_|V|[ce,se] if Q_Mtep_|V|[ce,se] <> 0 on ce) if Q_Mtep_|V|[se] <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_|V| = sum(Q_Mtep_|V|[se] if Q_Mtep_|V|[se] <> 0 on se) if Q_Mtep_|V| <> 0 where V in ep ef X int Losses indus ef_tot
    
    Q_Mtep_indus[ce] = sum(Q_Mtep_indus[ce,sne] on sne)   
    
    Q_Mtep_H_BUIL = sum(Q_Mtep_H_BUIL[ce] on ce)
    
    Q_Mtep_H_AUTO = sum(Q_Mtep_H_AUTO[ce] on ce)
    
    Q_Mtep_SEC_SOU[ce] = sum(Q_Mtep_SEC[ce, sne] on sne)
    
    Q_Mtep_SEC[sne] = sum(Q_Mtep_SEC[ce, sne] on ce)
    
    Q_Mtep_H = Q_mtep_H_BUIL + Q_mtep_H_AUTO
    
    Q_Mtep_SEC = sum(Q_Mtep_SEC_SOU[ce] on ce)
    
    verif_Q_Mtep_ep = Q_Mtep_ef + Q_Mtep_Losses + Q_Mtep_int + Q_Mtep_X - Q_Mtep_ep
    
    verif_Q_Mtep_ef_SOU[ce] = sum(Q_Mtep_ef[ce,se] on se) - Q_Mtep_ef_SOU[ce]
    
    verif_Q_Mtep_X_SOU[ce] = sum(Q_Mtep_X[ce,se] on se) - Q_Mtep_X_SOU[ce]
    
    Verif_Q_Mtep_HSEC = Q_Mtep_H + Q_Mtep_SEC - Q_Mtep_ef
    
    # Exception for energy (Distinction between energy indus / other)
    
    #CU_oth[s]*Y[s] = CK[s]*K[s] + CL[s]*L[s]*PROG_L[s] + PE[s]*E_oth[s] + PMAT[s]*MAT[s] if Y[s] > 0
    
    # E_oth[s]: energy used within sector s for energy purposes (ex: electricity for steel making)
    
    d(log(E_oth_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E[s])) if E_oth_n[s] <> 0
    
    # E_indus[s]: energy carrier used within sector s for non-energy purposes (ex: petrochemical feedstock)
    
    d(log(E_indus_n[s])) = d(log(Y[s])) + d(SUBST_E[s]) - d(log(PROG_E_indus[s])) if E_indus_n[s] <> 0     #modifié
    
    # Ajustment of E_oth[s] and E_indus[s]
    
    log(|V|[s]) = ADJUST(2 + $V, 1) * log(|V|_n[s]) + (1 - ADJUST(2 + $V, 1)) * (log(|V|[s]{-1}) + d(log(|V|_e[s]))) if |V|[s] <> 0 where V in E_oth E_indus, s in %list_sec
    
    # E_oth[s] = sum( E_oth[ce, s] on ce )
    
    # E_indus[s] = sum( E_indus[ce, s] on ce )
    
    d(log(|V|_e[s])) = ADJUST(2 + $V, 2) * d(log(|V|_e[s]{-1})) + ADJUST(2 +$V, 3) * d(log(|V|[s]{-1})) + ADJUST(2 + $V, 4) * d(log(|V|_n[s])) if |V|[s] <> 0 where V in E_oth E_indus
    
    # equation 2.20
    
    d(log(E_indus[ce, s])) = d(log(E_indus[s])) + d(SUBST_E[ce, s]) if E_indus[ce, s] <> 0
    
    d(log(E_oth[ce, s])) = d(log(E_oth[s])) + d(SUBST_E[ce, s]) if E_oth[ce, s] <> 0
    
    E_indus_SOU[ce] = sum( E_indus[ce, s] on s )
    
    E_oth_SOU[ce] = sum( E_oth[ce, s] on s)
    
    # Internal energy use in energy producing sectors
    
    E_oth_SOU_ener[ce] = sum(E_oth[ce, se] on se)
    
    # Internal energy use in non-energy producing sectors
    
    E_oth_SOU_non_ener[ce] = sum(E_oth[ce, sne] on sne)
    
    @over E[ce, s] = E_indus[ce, s] + E_oth[ce, s] if E[ce, s] <> 0
    
    @over E[s] = E_indus[s] + E_oth[s]  if E[s] <> 0
    
    verif_E[s] = sum( E[ce, s] on ce ) - E[s] if E[s] <> 0




# Cross-consumption between energy sectors
# Q_Mtep_ener_in[ce, se]: intermediate energy consumed by sector se to produce energy commodity ce
# Q_Mtep_ener_out[ce, se]: intermediate energy ce produced by sector se to be consumed by other energy sectors

@over Q_Mtep_ef_tot[ce, se] = Q_Mtep_ef[ce, se]  + Q_Mtep_X[ce, se] + Q_Mtep_Nener[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ef_tot[ce, se] <> 0

# Take cross-consumptions into account for primary energy consumption

@over Q_Mtep_ep[ce, se] = Q_Mtep_ef[ce, se] + Q_Mtep_X[ce, se] + Q_Mtep_int[ce, se] + Q_Mtep_Losses[ce, se] - Q_Mtep_in[ce, se] + Q_Mtep_out[ce, se] if Q_Mtep_ep[ce,se] <> 0


##################################################################################################################################
##################################################################################################################################
##################################################################################################################################
